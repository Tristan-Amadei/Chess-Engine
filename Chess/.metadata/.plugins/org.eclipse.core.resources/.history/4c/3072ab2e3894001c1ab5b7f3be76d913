package game.opponent;

import java.util.List;

import game.*;
import game.MoveTypeClass.MoveType;
import game.opponent.TranspositionTable.FLAG;

public class Engine {

	public Move bestMove;
	public int nb_positions_reached;

	public Engine() {
		this.bestMove = null;
		this.nb_positions_reached = 0;
	}

	public double alpha_beta_negamax(Board board, double alpha, double beta, int depth) {
		if (depth <= 0) {
			return Evaluation.overallEvaluation(board);
		}

		List<Move> allMoves = board.allLegalMoves();
		Move.sortMoves(allMoves);
		for (Move move : allMoves) {
			move.playMove(board);
			nb_positions_reached++;
			double score = (-1) * alpha_beta_negamax(board, (-1) * beta, (-1) * alpha, depth - 1);
			board.unmakeMove();
			if (score >= alpha) {
				alpha = score;
				bestMove = move;
				if (alpha >= beta) {
					return beta;
				}
			}
		}
		return alpha;
	}

	public static void playBestMove_negamax(Board board, int depth) {
		long t0 = System.currentTimeMillis();

		Engine engine = new Engine();
		engine.alpha_beta_negamax(board, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, depth);
		engine.bestMove.playMove(board);

		long t1 = System.currentTimeMillis();
		System.out.println("Total time to find move at a depth of " + depth + ": " + (t1 - t0) / 1000
				+ " s. Went through " + engine.nb_positions_reached + " positions.");
	}

	public double alphaBetaMax(Board board, double alpha, double beta, int depth) {
		if (depth <= 0) {
			return Evaluation.overallEvaluation(board);
			//return searchAllCaptures(board, alpha, beta);
		}

		List<Move> allMoves = board.allLegalMoves();
		Move.sortMoves(allMoves);
		for (Move move : allMoves) {
			nb_positions_reached++;
			move.playMove(board);
			long zKey_position = board.zKey.getZobristHash(board);
			double score = this.alphaBetaMin(board, alpha, beta, depth - 1);
			if (score >= beta) {
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFBETA);
				return beta;
			}
			if (score > alpha) {
				alpha = score;
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFEXACT);
			} else {
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFALPHA);
			}
			board.unmakeMove();
		}
		return alpha;
	}

	public double alphaBetaMin(Board board, double alpha, double beta, int depth) {
		if (depth <= 0) {
			return Evaluation.overallEvaluation(board);
			//return searchAllCaptures(board, alpha, beta);
		}

		List<Move> allMoves = board.allLegalMoves();
		Move.sortMoves(allMoves);
		for (Move move : allMoves) {
			nb_positions_reached++;
			move.playMove(board);
			long zKey_position = board.zKey.getZobristHash(board);
			double score = this.alphaBetaMax(board, alpha, beta, depth - 1);
			if (score <= alpha) {
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFALPHA);
				return alpha;
			}
			if (score < beta) {
				beta = score;
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFEXACT);
			} else {
				TranspositionTable.addToTable(zKey_position, move, score, alpha, beta, depth, FLAG.HFBETA);
			}
			board.unmakeMove();
		}
		return beta;
	}

	/*public static void playBestMove_alphaBeta(Board board, int depth, boolean color) {
		long t0 = System.currentTimeMillis();

		List<Move> allMoves = board.allLegalMoves();
		Engine engine = new Engine();
		Move bestMove = allMoves.get(0);
		double score_max;
		if (color) {
			score_max = Double.NEGATIVE_INFINITY;
		} else {
			score_max = Double.POSITIVE_INFINITY;
		}

		for (Move move : allMoves) {
			move.playMove(board);
			if (color) {
				double score = engine.alphaBetaMin(board, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, depth);
				if (score >= score_max) {
					score_max = score;
					bestMove = move;
				}
			} else {
				double score = engine.alphaBetaMax(board, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, depth);
				if (score <= score_max) {
					score_max = score;
					bestMove = move;
				}
			}
			board.unmakeMove();
		}
		
		bestMove.playMove(board);
		long t1 = System.currentTimeMillis();
		bestMove.display();
		if ((t1-t0)/1000 > 60) {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / (1000*60)
					+ " min, " + ((t1-t0)/1000 - 60*((t1 - t0) / (1000*60))) + " s. Went through ");
		} else {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / 1000
					+ " s. Went through " + engine.nb_positions_reached + " positions.");
		}
	} */
	
	public static Engine returnBestMove_alphaBeta(Board board, int depth, boolean color, List<Move> allMoves) {
		Engine engine = new Engine();
		Move bestMove = allMoves.get(0);
		double score_max;
		if (color) {
			score_max = Double.NEGATIVE_INFINITY;
		} else {
			score_max = Double.POSITIVE_INFINITY;
		}

		for (Move move : allMoves) {
			move.playMove(board);
			if (color) {
				double score = engine.alphaBetaMin(board, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, depth);
				if (score >= score_max) {
					score_max = score;
					bestMove = move;
				}
			} else {
				double score = engine.alphaBetaMax(board, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, depth);
				if (score <= score_max) {
					score_max = score;
					bestMove = move;
				}
			}
			board.unmakeMove();
		}
		engine.bestMove = bestMove;
		return engine;
	}
	
	public static void playBestMove_alphaBeta(Board board, int depth, boolean color) {
		long t0 = System.currentTimeMillis();
		
		List<Move> allMoves = board.allLegalMoves();
		Move.sortMoves(allMoves);
		Engine engine = returnBestMove_alphaBeta(board, depth, color, allMoves);
		Move bestMove = engine.bestMove;

		bestMove.playMove(board);
		long t1 = System.currentTimeMillis();
		bestMove.display();
		if ((t1-t0)/1000 > 60) {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / (1000*60)
					+ " min, " + ((t1-t0)/1000 - 60*((t1 - t0) / (1000*60))) + " s. Went through " + engine.nb_positions_reached + " positions.");
		} else {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / 1000
					+ " s. Went through " + engine.nb_positions_reached + " positions.");
		}
	}
	
	public static double searchAllCaptures(Board board, double alpha, double beta) {
		double evaluation = Evaluation.overallEvaluation(board);
		if (evaluation >= beta) {
			return beta;
		}
		alpha = Double.max(alpha, evaluation);
		
		List<Move> allCaptures = board.allCaptureMoves();
		Move.sortMoves(allCaptures);
		
		for(Move capture : allCaptures) {
			capture.playMove(board);
			evaluation = -searchAllCaptures(board, -beta, -alpha);
			board.unmakeMove();
			
			if (evaluation >= beta) {
				return beta;
			}
			alpha = Double.max(alpha, evaluation);
		}
		return alpha;
	}
	
	public static void playBestMove_iterativeDeepening(Board board, int depth, boolean color) {
		long t0 = System.currentTimeMillis();
		
		Move bestMove = null;
		int nb_positions_reached = 0;
		Engine en = new Engine();
		
		List<Move> allMoves = board.allLegalMoves();
		Move.sortMoves(allMoves);
		for (int i = 1; i<=depth; i++) {
			en = returnBestMove_alphaBeta(board, i, color, allMoves);
			bestMove = en.bestMove;
			nb_positions_reached += en.nb_positions_reached;
			for (Move move : allMoves) {
				if (move.equalsTo(bestMove)) {
					move.moveType = MoveType.FoundByAlphaBeta;
					break;
				}
			}
			Move.sortMoves(allMoves);
			System.out.println("Depth: " + i);
			for(Move move : allMoves) {
				move.display();
			}
		}
		
		bestMove.playMove(board);
		long t1 = System.currentTimeMillis();
		bestMove.display();
		if ((t1-t0)/1000 > 60) {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / (1000*60)
					+ " min, " + ((t1-t0)/1000 - 60*((t1 - t0) / (1000*60))) + " s. Went through " + nb_positions_reached + " positions.");
		} else {
			System.out.println("Total time to find move at a depth of " + (depth + 1) + ": " + (t1 - t0) / 1000
					+ " s. Went through " + nb_positions_reached + " positions.");
		}
	}

}
