package game.opponent;

import java.util.*;

import game.*;
import game.opponent.TranspositionTableProbing.ProbingResult;

public class TranspositionTable {
	
	public enum FLAG {
		HFNONE, 
		HFALPHA, 
		HFBETA, 
		HFEXACT
	}
	
	public Hashtable<Long, Move> wMoveTable;
	public Hashtable<Long, Double> wEvalTable;
	public Hashtable<Long, Double> wAlphaTable;
	public Hashtable<Long, Double> wBetaTable;
	public Hashtable<Long, Integer> wDepthTable;
	public Hashtable<Long, FLAG> wFlagTable; 
	
	public TranspositionTable() {
		wMoveTable = new Hashtable<>();
		wEvalTable = new Hashtable<>();
		wAlphaTable = new Hashtable<>();
		wBetaTable = new Hashtable<>();
		wDepthTable = new Hashtable<>();
		wFlagTable = new Hashtable<>();		
	}
	
	public void addToTable(long ZobristKey, Move move, Double eval, Double alpha, Double beta, int depth, FLAG flag) {
		wMoveTable.put(ZobristKey, move);
		wEvalTable.put(ZobristKey, eval);
		wAlphaTable.put(ZobristKey, alpha);
		wBetaTable.put(ZobristKey, beta);
		wDepthTable.put(ZobristKey, depth);
		wFlagTable.put(ZobristKey, flag);
	}
	
	/*
	public TranspositionTableProbing probeHash(Board board, int depth, double alpha, double beta) {
		TranspositionTableProbing returning = new TranspositionTableProbing();
		
		long zKey_position = board.zKey.getZobristHash(board);
		if (moveTable.containsKey(zKey_position)) { //then all other tables do possess this key too
			
			//Move move = moveTable.get(zKey_position);
			double eval = evalTable.get(zKey_position);
			double alpha_table = alphaTable.get(zKey_position);
			double beta_table = betaTable.get(zKey_position);
			int depth_table = depthTable.get(zKey_position);
			FLAG flag = flagTable.get(zKey_position);
			
			if (depth_table >= depth) {
				returning.result = ProbingResult.OK;
				switch(flag) {
				case HFEXACT:
					returning.score = eval;
					return returning;
				case HFALPHA:
					if (Math.abs(eval) <= Math.abs(alpha)) {
						returning.score = alpha;
						return returning;
					}
					returning.score = alpha_table;
					return returning;
				case HFBETA:
					if (Math.abs(eval) >= Math.abs(beta)) {
						returning.score = beta;
						return returning;
					}
					//returning.score = eval;
					returning.score = beta_table;
					return returning;
				default:
					returning.score = eval;
					return returning;
				}
			} else {
				returning.result = ProbingResult.NotOK;
				return returning;
			}
		} else {
			returning.result = ProbingResult.NotOK;
			return returning;
		}
	} */
	
	public TranspositionTableProbing probeHash(Board board, int depth, double alpha, double beta) {
		TranspositionTableProbing returning = new TranspositionTableProbing();
		
		long zKey_position = board.zKey.getZobristHash(board);
		if (wMoveTable.containsKey(zKey_position)) { //then all other tables do possess this key too
			
			//Move move = moveTable.get(zKey_position);
			double eval = wEvalTable.get(zKey_position);
			double alpha_table = wAlphaTable.get(zKey_position);
			double beta_table = wBetaTable.get(zKey_position);
			int depth_table = wDepthTable.get(zKey_position);
			FLAG flag = wFlagTable.get(zKey_position);
			
			if (depth_table >= depth) {
				returning.result = ProbingResult.OK;
				switch(flag) {
				case HFEXACT:
					returning.score = eval;
					return returning;
				case HFALPHA:
					if (Math.abs(eval) <= Math.abs(alpha)) {
						returning.score = alpha;
						return returning;
					}
					returning.score = eval;
					//returning.result = ProbingResult.NotOK;
					return returning;
				case HFBETA:
					if (Math.abs(eval) >= Math.abs(beta)) {
						returning.score = beta;
						return returning;
					}
					returning.score = eval;
					//returning.result = ProbingResult.NotOK;
					return returning;
				default:
					returning.result = ProbingResult.NotOK;
					returning.score = eval;
					return returning;
				}
			} else {
				returning.result = ProbingResult.NotOK;
				return returning;
			}
		} else {
			returning.result = ProbingResult.NotOK;
			return returning;
		}
	}

}
