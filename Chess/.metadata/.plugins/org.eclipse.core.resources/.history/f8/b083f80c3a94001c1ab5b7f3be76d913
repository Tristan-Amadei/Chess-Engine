package game.opponent;

import java.util.*;

import game.*;

public class TranspositionTable {
	
	public enum FLAG {
		HFNONE, 
		HFALPHA, 
		HFBETA, 
		HFEXACT
	}
	
	public static Hashtable<Long, Move> moveTable = new Hashtable<>();
	public static Hashtable<Long, Double> evalTable = new Hashtable<>();
	public static Hashtable<Long, Double> alphaTable = new Hashtable<>();
	public static Hashtable<Long, Double> betaTable = new Hashtable<>();
	public static Hashtable<Long, Integer> depthTable = new Hashtable<>();
	public static Hashtable<Long, FLAG> flagTable = new Hashtable<>();
	
	public static void addToTable(long ZobristKey, Move move, Double eval, Double alpha, Double beta, int depth, FLAG flag) {
		moveTable.put(ZobristKey, move);
		evalTable.put(ZobristKey, eval);
		alphaTable.put(ZobristKey, alpha);
		betaTable.put(ZobristKey, beta);
		depthTable.put(ZobristKey, depth);
		flagTable.put(ZobristKey, flag);
	}
	
	public static double probeHash(Board board, int depth, double alpha, double beta) {
		long zKey_position = board.zKey.getZobristHash(board);
		if (moveTable.containsKey(zKey_position)) { //then all other tables do possess this key too
			
			Move move = moveTable.get(zKey_position);
			double eval = evalTable.get(zKey_position);
			double alpha_table = alphaTable.get(zKey_position);
			double beta_table = betaTable.get(zKey_position);
			int depth_table = depthTable.get(zKey_position);
			FLAG flag = flagTable.get(zKey_position);
			
			if (depth_table >= depth) {
				switch(flag) {
				case HFEXACT:
					return eval;
				case HFALPHA:
					if (Math.abs(eval) <= Math.abs(alpha)) {
						return alpha;
					}
					return alpha_table;
				case HFBETA:
					if (Math.abs(eval) >= Math.abs(beta)) {
						return beta;
					}
					return beta_table;
				default:
					return eval;
				}
				
			}
		}
	}

}
