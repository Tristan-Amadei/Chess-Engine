package game.adversary;

import java.util.HashSet;

import game.*;

public class Engine {	
/*
int alphabêta(int depth, int alpha, int bêta)
{
   if (game over or depth <= 0)
      return winning score or eval();
   move bestmove ;
   for (each possible move m) {
      make move m;
      int score = -alphabêta(depth - 1, -bêta, -alpha)
      unmake move m;
      if (score >= alpha){
         alpha = score ;
         bestMove = m ;
         if (alpha >= bêta)
            break;
      }
   }
   return alpha;
} */

public static double alpha_beta_negamax(Board board, double alpha, double beta, int depth) {
	if (depth <= 0) {
		return Evaluation.boardEvaluation(board);
	}
	
	Move bestMove;
	for (int i=0; i<8; i++) {
		for (int j=0; j<8; j++) {
			if (board.board[i][j] != null && board.board[i][j].legalMoves(board, i, j).size() > 0) { //piece that can move on this square
				HashSet<Short> moves = board.board[i][j].legalMoves(board, i, j);
			}
		}
	}
}
	
}
