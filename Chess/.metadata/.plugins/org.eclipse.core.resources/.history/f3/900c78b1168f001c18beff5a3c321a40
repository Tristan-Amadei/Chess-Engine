package game.adversary;

import java.util.HashSet;

import game.*;

public class Engine {	
/*
int alphabêta(int depth, int alpha, int bêta)
{
   if (game over or depth <= 0)
      return winning score or eval();
   move bestmove ;
   for (each possible move m) {
      make move m;
      int score = -alphabêta(depth - 1, -bêta, -alpha)
      unmake move m;
      if (score >= alpha){
         alpha = score ;
         bestMove = m ;
         if (alpha >= bêta)
            break;
      }
   }
   return alpha;
} */

public static double alpha_beta_negamax(Board board, double alpha, double beta, int depth) {
	if (depth <= 0) {
		return Evaluation.boardEvaluation(board);
	}
	
	Move bestMove;
	for (int i=0; i<8; i++) {
		for (int j=0; j<8; j++) {
			if (board.board[i][j] != null && board.board[i][j].legalMoves(board, i, j).size() > 0) { //piece that can move on this square
				HashSet<Short> moves = board.board[i][j].legalMoves(board, i, j);
				for (short move : moves) {
					try {
						board.board[i][j].movePiece(board, i, j, move/10, move-10*(move/10));
						double score = (-1)*alpha_beta_negamax(board, -beta, -alpha, depth-1);
						if (score >= alpha) {
							alpha = score;
							bestMove = board.movesPlayed.get(board.movesPlayed.size()-1);
							if (alpha >= beta) {
								break;
							}
						}
						board.unmakeMove();
					} catch (Exception e) {
						
					}
				}
			}
		}
	}
}
	
}
