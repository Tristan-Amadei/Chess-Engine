!SESSION 2022-02-09 23:36:00.862 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-09 23:36:19.883
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 23:36:19.883
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@644947ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25421809,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-09 23:36:28.226
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-09 23:36:58.739 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-09 23:37:03.802
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 23:37:03.802
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@10a0a1e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2976ef56,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-09 23:37:08.964
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-10 12:11:57.474 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-10 12:15:13.198
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 12:15:13.198
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f0cab82,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7fcc3745,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-10 12:15:25.304
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-10 15:07:42.213 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-10 15:07:50.199
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 15:07:50.199
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c69e1e1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7b52b18a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-10 15:07:58.974
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-02-12 15:07:19.329
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, )
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
		
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
		board.movesPlayed.add(move);
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type == PieceType.Pawn) {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
			} else {
				board.board[dest_line-1][dest_column] = null;
			}
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
			board.movesPlayed.add(move);
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-12 15:07:19.331
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-12 15:07:19.331
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-12 15:07:26.340
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src)
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
		
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
		board.movesPlayed.add(move);
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type == PieceType.Pawn) {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
			} else {
				board.board[dest_line-1][dest_column] = null;
			}
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
			board.movesPlayed.add(move);
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-12 15:07:26.341
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-12 15:07:26.341
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-12 15:07:31.348
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int )
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
		
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
		board.movesPlayed.add(move);
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type == PieceType.Pawn) {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
			} else {
				board.board[dest_line-1][dest_column] = null;
			}
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
			board.movesPlayed.add(move);
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-12 15:07:31.349
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-12 15:07:31.349
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-12 15:07:34.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column)
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
		
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
		board.movesPlayed.add(move);
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type == PieceType.Pawn) {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
			} else {
				board.board[dest_line-1][dest_column] = null;
			}
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
			board.movesPlayed.add(move);
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-12 15:07:34.356
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-12 15:07:34.356
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-12 15:08:36.462
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) {
		try {
			this.normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column)
		} catch (IllegalMoveException e) {
			
		}
		/*
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			System.out.println("The move " + this.type + ": [" + src_line + ", " 
		+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
			throw new IllegalMoveException();
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
		
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
		board.movesPlayed.add(move);
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type == PieceType.Pawn) {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
			} else {
				board.board[dest_line-1][dest_column] = null;
			}
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square);
			board.movesPlayed.add(move);
		}
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-12 15:08:36.463
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-12 15:08:36.463
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-13 00:38:20.261
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured
			System.out.println-"The KIng is in check"
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-13 00:38:20.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-13 00:38:20.264
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-13 00:38:20.271
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured
			System.out.println-"The KIng is in check"
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-13 00:38:20.272
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-13 00:38:20.272
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-02-13 12:27:26.888 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-13 12:28:12.908
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-13 12:28:12.908
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30ed2a26,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bf10539,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-13 12:28:12.908
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e406cbe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@141a10bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-13 12:28:20.628
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-02-13 12:54:31.285
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.AbstractDocument.getChar(AbstractDocument.java:783)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getChar(SynchronizableDocument.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getBracketHoverInfo(JavaSourceHover.java:177)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 13:00:41.929
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:338)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeLabelProvider.getImage(DebugTypeSelectionDialog.java:68)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeDetailsLabelProvider.getImage(DebugTypeSelectionDialog.java:163)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.refresh(FilteredItemsSelectionDialog.java:2882)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.inputChanged(FilteredItemsSelectionDialog.java:2851)
	at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:282)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refreshDetails(FilteredItemsSelectionDialog.java:771)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.handleSelected(FilteredItemsSelectionDialog.java:838)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.lambda$5(FilteredItemsSelectionDialog.java:662)
	at org.eclipse.jface.viewers.Viewer$1.run(Viewer.java:151)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2132)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1178)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1207)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:242)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:237)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:402)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refresh(FilteredItemsSelectionDialog.java:884)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$RefreshJob.runInUIThread(FilteredItemsSelectionDialog.java:1307)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.handleSearchButtonSelected(JavaMainTab.java:186)
	at org.eclipse.jdt.internal.debug.ui.launcher.SharedJavaMainTab$2.widgetSelected(SharedJavaMainTab.java:81)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1209)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 13:00:41.933
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:338)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeLabelProvider.getImage(DebugTypeSelectionDialog.java:68)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeDetailsLabelProvider.getImage(DebugTypeSelectionDialog.java:163)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.refresh(FilteredItemsSelectionDialog.java:2882)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.inputChanged(FilteredItemsSelectionDialog.java:2851)
	at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:282)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refreshDetails(FilteredItemsSelectionDialog.java:771)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.handleSelected(FilteredItemsSelectionDialog.java:838)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.lambda$5(FilteredItemsSelectionDialog.java:662)
	at org.eclipse.jface.viewers.Viewer$1.run(Viewer.java:151)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2132)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1178)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1207)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:242)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:237)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:402)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refresh(FilteredItemsSelectionDialog.java:884)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$RefreshJob.runInUIThread(FilteredItemsSelectionDialog.java:1307)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.handleSearchButtonSelected(JavaMainTab.java:186)
	at org.eclipse.jdt.internal.debug.ui.launcher.SharedJavaMainTab$2.widgetSelected(SharedJavaMainTab.java:81)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1209)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 13:00:41.935
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:338)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeLabelProvider.getImage(DebugTypeSelectionDialog.java:68)
	at org.eclipse.jdt.internal.debug.ui.launcher.DebugTypeSelectionDialog$DebugTypeDetailsLabelProvider.getImage(DebugTypeSelectionDialog.java:163)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.refresh(FilteredItemsSelectionDialog.java:2882)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$DetailsContentViewer.inputChanged(FilteredItemsSelectionDialog.java:2851)
	at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:282)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refreshDetails(FilteredItemsSelectionDialog.java:771)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.handleSelected(FilteredItemsSelectionDialog.java:838)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.lambda$5(FilteredItemsSelectionDialog.java:662)
	at org.eclipse.jface.viewers.Viewer$1.run(Viewer.java:151)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2132)
	at org.eclipse.jface.viewers.StructuredViewer.handleSelect(StructuredViewer.java:1178)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetSelected(StructuredViewer.java:1207)
	at org.eclipse.jface.util.OpenStrategy.fireSelectionEvent(OpenStrategy.java:242)
	at org.eclipse.jface.util.OpenStrategy.access$4(OpenStrategy.java:237)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:402)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refresh(FilteredItemsSelectionDialog.java:884)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$RefreshJob.runInUIThread(FilteredItemsSelectionDialog.java:1307)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.handleSearchButtonSelected(JavaMainTab.java:186)
	at org.eclipse.jdt.internal.debug.ui.launcher.SharedJavaMainTab$2.widgetSelected(SharedJavaMainTab.java:81)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1209)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-13 13:31:32.404
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 16:16:33.299
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:79)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage.handleAdvancedButtonSelect(WizardNewFolderMainPage.java:521)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage$1.widgetSelected(WizardNewFolderMainPage.java:176)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.handlers.WizardHandler$New.executeHandler(WizardHandler.java:263)
	at org.eclipse.ui.internal.handlers.WizardHandler.execute(WizardHandler.java:283)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor86.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommand(LegacyHandlerService.java:389)
	at org.eclipse.ui.internal.actions.CommandAction.runWithEvent(CommandAction.java:142)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 16:16:33.302
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:338)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage.handleAdvancedButtonSelect(WizardNewFolderMainPage.java:534)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage$1.widgetSelected(WizardNewFolderMainPage.java:176)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.handlers.WizardHandler$New.executeHandler(WizardHandler.java:263)
	at org.eclipse.ui.internal.handlers.WizardHandler.execute(WizardHandler.java:283)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor86.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommand(LegacyHandlerService.java:389)
	at org.eclipse.ui.internal.actions.CommandAction.runWithEvent(CommandAction.java:142)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.ide 4 4 2022-02-13 16:16:33.302
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:338)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage.handleAdvancedButtonSelect(WizardNewFolderMainPage.java:545)
	at org.eclipse.ui.dialogs.WizardNewFolderMainPage$1.widgetSelected(WizardNewFolderMainPage.java:176)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.handlers.WizardHandler$New.executeHandler(WizardHandler.java:263)
	at org.eclipse.ui.internal.handlers.WizardHandler.execute(WizardHandler.java:283)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor86.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommand(LegacyHandlerService.java:389)
	at org.eclipse.ui.internal.actions.CommandAction.runWithEvent(CommandAction.java:142)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
!SESSION 2022-02-14 14:49:45.998 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-14 14:50:15.915
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 14:50:15.916
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@61becbcf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20171cdc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 14:50:15.916
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f97013,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7d70ba18,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-14 14:50:29.355
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-14 14:50:29.666
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
!SESSION 2022-02-14 20:35:00.635 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-14 20:35:06.408
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 20:35:06.408
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77b27b57,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7adff6cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 20:35:06.408
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13ebccd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e80960a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-14 20:35:13.211
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-14 20:38:16.385
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
!SESSION 2022-02-15 12:05:19.037 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-15 12:05:38.313
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 12:05:38.313
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2dd08ff1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37dec463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 12:05:38.313
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bf26810,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19213a74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-15 12:05:47.446
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-15 12:05:47.692
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-15 12:50:00.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public abstract HashSet<Short> legalMoves()
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured	
		System.out.println("The King is in check");
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-15 12:50:00.548
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-15 12:50:00.548
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-15 12:50:03.560
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public abstract HashSet<Short> legalMoves(Board board, )
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured	
		System.out.println("The King is in check");
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-15 12:50:03.561
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-15 12:50:03.562
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-15 12:50:06.072
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public abstract HashSet<Short> legalMoves(Board board, int i, int j)
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured	
		System.out.println("The King is in check");
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-15 12:50:06.073
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-15 12:50:06.074
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-15 17:54:40.499
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public abstract HashSet<Short> legalMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured	
		System.out.println("The King is in check");
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								//System.out.println("The move " + this.type + ": [" + src_line + ", " 
									//	+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								//System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-15 17:54:40.501
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-15 17:54:40.502
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-15 17:54:40.515
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package game.pieces;

import java.util.HashSet;
import game.*;
import game.MoveTypeClass.MoveType;
import game.pieces.PieceTypeClass.PieceType;

public abstract class Piece {
	
	protected PieceType type;
	
	/**
	 * 1 corresponds to Black; 0 to White
	 */
	protected boolean color;
	
	public Piece(final PieceType type, final boolean color) {
		this.type = type;
		this.color = color;
	}
	
	public PieceType getType() {
		return type;
	}
	
	public boolean getColor() {
		return color;
	}
	
	public abstract void display();
	
	public abstract HashSet<Short> possibleMoves(Board board, int i, int j);
	
	public abstract HashSet<Short> legalMoves(Board board, int i, int j);
	
	public void movePiece(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (checkMoveIsIllegal(board, src_line, src_column, dest_line, dest_column)) { //the move is not legal bc it lets the king be captured	
		System.out.println("The King is in check");
			throw new IllegalMoveException();
		}
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								//System.out.println("The move " + this.type + ": [" + src_line + ", " 
									//	+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
	}
	
	public void normalMove(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		Object start_square = (short)(10*src_line + src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) { //no piece was captured
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove(start_square);
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			//must force them as Object before removing them, otherwise Java thinks we want to remove an index, not an object
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Normal);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = this;
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
		
		if (type == PieceType.King) {
			((King) this).hasMoved = true;
			if (color) {
				board.whiteKingPosition = landing_square;
			} else {
				board.blackKingPosition = landing_square;
			}
		}
		if (type == PieceType.Rook) {
			((Rook) this).hasMoved = true;
		}
	}
	
	public void enPassant(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (type != PieceType.Pawn) { //not a pawn, hence cannot execute this special move
			throw new IllegalMoveException();
		} else {
			HashSet<Short> movesEP = ((Pawn)this).enPassant(board, src_line, src_column);
			short landing_square = (short) (10*dest_line + dest_column);
			
			if (!movesEP.contains(landing_square) || color != board.colorToPlay) {
				throw new IllegalMoveException();
			}
			
			board.board[dest_line][dest_column] = this;
			board.inGamePieces.add(landing_square);
			// delete the captured pawn from the board
			if (color) {
				board.board[dest_line+1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line+1) + dest_column)));
			} else {
				board.board[dest_line-1][dest_column] = null;
				board.inGamePieces.remove((Object)((short)(10*(dest_line-1) + dest_column)));
			}
			board.board[src_line][src_column] = null;
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
			
			board.colorToPlay = !board.colorToPlay;
			Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, PieceType.Pawn, MoveType.EnPassant);
			board.movesPlayed.add(move);
			
		}
	}
	
	public void kingSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column + 2) { //not a king side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][src_column + 3].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][src_column + 3];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).kingSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column + 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column+1));
		board.board[src_line][src_column + 3] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column + 3)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column + 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.KingSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void queenSideCastle(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (dest_column != src_column - 2) { //not a queen side castle
			throw new IllegalMoveException();
		}
		if (type != PieceType.King || ((King)this).hasMoved) { //either the piece is not a King, or it has already moved hence cannot castle
			throw new IllegalMoveException();
		}
		if (((King)this).isInCheck(board, src_line, src_column)) { //cannot castle if king's in check
			throw new IllegalMoveException();
		}
		if (board.board[src_line][0].type != PieceType.Rook) { //no rook on the right corner (either up or down) of the board
			throw new IllegalMoveException();
		}
		Rook corner_rook = (Rook) board.board[src_line][0];
		if (corner_rook.hasMoved) {
			throw new IllegalMoveException();
		}
		if (!((King)this).queenSideCastlePossible_squares(board, src_line, src_column)) { //some squares on the right of the king are controlled by the opponent
			throw new IllegalMoveException();
		}
		
		// finally, after all these tests, castling is possible
		//moving the king
		board.board[dest_line][dest_column] = this;
		board.inGamePieces.add((short)(10*dest_line + dest_column));
		board.board[src_line][src_column] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		//moving the rook
		board.board[src_line][src_column - 1] = corner_rook;
		board.inGamePieces.add((short)(10*src_line + src_column-1));
		board.board[src_line][0] = null;
		board.inGamePieces.remove((Object)((short)(10*src_line + 0)));
		
		((King) board.board[dest_line][dest_column]).hasMoved = true;
		((Rook) board.board[src_line][src_column - 1]).hasMoved = true;
		
		if (color) {
			board.whiteKingPosition = (short)(10*dest_line + dest_column);
		} else {
			board.blackKingPosition = (short)(10*dest_line + dest_column);
		}
		
		board.colorToPlay = !board.colorToPlay;
		Move move = new Move(type, color, (short) (10*src_line + src_column), (short) (10*dest_line + dest_column), null, MoveType.QueenSideCastle);
		board.movesPlayed.add(move);
	}
	
	public void pawnPromotion_white(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color == false || type != PieceType.Pawn || src_line != 1) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public void pawnPromotion_black(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		if (color==true || type != PieceType.Pawn || src_line != 6) {
			throw new IllegalMoveException();
		}
		
		HashSet<Short> moves = this.possibleMoves(board, src_line, src_column);
		short landing_square = (short) (10*dest_line + dest_column);
		
		if (!moves.contains(landing_square) || color != board.colorToPlay) {
			throw new IllegalMoveException();
		}
		
		PieceType hypotheticalCapturedPieceType;
		if (board.board[dest_line][dest_column] == null) {
			hypotheticalCapturedPieceType = null;
			board.inGamePieces.add(landing_square);
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		} else {
			hypotheticalCapturedPieceType = board.board[dest_line][dest_column].type;
			//no need to add landing_square to the list for it is already in it, as a piece there is getting captured
			board.inGamePieces.remove((Object)((short)(10*src_line + src_column)));
		}
		Move move = new Move(type, color, (short) (10*src_line + src_column), landing_square, hypotheticalCapturedPieceType, MoveType.Promotion);
		board.movesPlayed.add(move);
		
		board.board[dest_line][dest_column] = new Queen(color);
		board.board[src_line][src_column] = null;
		board.colorToPlay = !board.colorToPlay;
	}
	
	public boolean checkMoveIsIllegal(Board board, int src_line, int src_column, int dest_line, int dest_column) throws IllegalMoveException {
		try {
			pawnPromotion_white(board, src_line, src_column, dest_line, dest_column);
		} catch (IllegalMoveException promotionWhiteIllegal) {
			try {
				pawnPromotion_black(board, src_line, src_column, dest_line, dest_column);
			} catch (IllegalMoveException promotionBlackIllegal) {
				try {
					this.normalMove(board, src_line, src_column, dest_line, dest_column);
				} catch (IllegalMoveException normalMoveIllegal) {
					try {
						this.enPassant(board, src_line, src_column, dest_line, dest_column);
					} catch (IllegalMoveException enPassantIllegal) {
						try {
							this.kingSideCastle(board, src_line, src_column, dest_line, dest_column);
						} catch (IllegalMoveException kingSideCastleIllegal) {
							try {
								this.queenSideCastle(board, src_line, src_column, dest_line, dest_column);
							} catch (IllegalMoveException queenSideCastleIllegal) {
								//System.out.println("The move " + this.type + ": [" + src_line + ", " 
										+ src_column + "] -> [" + dest_line + ", " + dest_column + "] is illegal");
								throw new IllegalMoveException();
							}
						}
					}
				}
			}
		}
		short king_position = board.getKingPosition(!board.colorToPlay); 
		int king_line = king_position/10;
		int king_column = king_position - 10*king_line;
		boolean king_is_in_check = ((King) board.board[king_line][king_column]).isInCheck(board, king_line, king_column);
		board.unmakeMove();
		return king_is_in_check;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-15 17:54:40.516
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-15 17:54:40.516
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-02-15 21:21:22.864 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-15 21:21:46.019
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 21:21:46.019
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19213a74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30a791a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 21:21:46.019
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@719bb60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5981f2c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-15 21:21:53.073
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-17 09:07:02.797
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
!SESSION 2022-02-18 10:43:44.671 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-18 10:44:35.644
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-18 10:44:35.644
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19213a74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30a791a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-18 10:44:35.644
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@719bb60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5981f2c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-18 10:44:43.594
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-18 10:44:43.876
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-02-18 12:04:13.402
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import game.MoveTypeClass.MoveType;
import game.opponent.Engine;
import javafx.fxml.FXML;
import javafx.scene.Cursor;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;

public class Controller {
	
	@FXML
	public void opponentPlay(KeyEvent e) {
		KeyCode code = e.getCode();
		  switch(code) {
			case ENTER:
				System.out.println("Enter");
				/*
				Engine.playBestMove_alphaBeta(RunningGUI.gameBoard, 4, RunningGUI.gameBoard.colorToPlay);
				RunningGUI.gameBoard.display();
				movePiece(0, 0);
				*/
				break;
			case LEFT:
				System.out.println("Left");
				/*
				RunningGUI.gameBoard.unmakeMove();
				RunningGUI.gameBoard.display();
				movePiece(0, 0);
				*/
				break;
			default: break;
		}
	}
	
	public void tes()
	
	@FXML
	private ImageView WRook1;
	private double xwRook1;
	private double ywRook1;
	private int line_WRook1 = 7;
	private int col_WRook1 = 0;
	@FXML
	private ImageView WRook2;
	private double xwRook2;
	private double ywRook2;
	private int line_WRook2 = 7;
	private int col_WRook2 = 7;
	@FXML
	private ImageView BRook1;
	private double xbRook1;
	private double ybRook1;
	private int line_BRook1 = 0;
	private int col_BRook1 = 0;
	@FXML
	private ImageView BRook2;
	private double xbRook2;
	private double ybRook2;
	private int line_BRook2 = 0;
	private int col_BRook2 = 7;
	
	@FXML
	private ImageView WKnight1;
	private double xwKnight1 = 87.5;
	private double ywKnight1 = 612.5;
	private int line_WKnight1 = 7;
	private int col_WKnight1 = 1;
	@FXML
	private ImageView WKnight2;
	private double xwKnight2;
	private double ywKnight2;
	private int line_WKnight2 = 7;
	private int col_WKnight2 = 6;
	@FXML
	private ImageView BKnight1;
	private double xbKnight1;
	private double ybKnight1;
	private int line_BKnight1 = 0;
	private int col_BKnight1 = 1;
	@FXML
	private ImageView BKnight2;
	private double xbKnight2;
	private double ybKnight2;
	private int line_BKnight2 = 0;
	private int col_BKnight2 = 6;
	
	@FXML
	private ImageView WBishop1;
	private double xwBishop1;
	private double ywBishop1;
	private int line_WBishop1 = 7;
	private int col_WBishop1 = 2;
	@FXML
	private ImageView WBishop2;
	private double xwBishop2;
	private double ywBishop2;
	private int line_WBishop2 = 7;
	private int col_WBishop2 = 5;
	@FXML
	private ImageView BBishop1;
	private double xbBishop1;
	private double ybBishop1;
	private int line_BBishop1 = 0;
	private int col_BBishop1 = 2;
	@FXML
	private ImageView BBishop2;
	private double xbBishop2;
	private double ybBishop2;
	private int line_BBishop2 = 0;
	private int col_BBishop2 = 5;
	
	@FXML
	private ImageView WQueen;
	private double xwQueen;
	private double ywQueen;
	private int line_WQueen = 7;
	private int col_WQueen = 3;
	@FXML
	private ImageView BQueen;
	private double xbQueen;
	private double ybQueen;
	private int line_BQueen = 0;
	private int col_BQueen = 3;
	
	@FXML
	private ImageView WKing;
	private double xwKing;
	private double ywKing;
	private int line_WKing = 7;
	private int col_WKing = 4;
	@FXML
	private ImageView BKing;
	private double xbKing;
	private double ybKing;
	private int line_BKing = 0;
	private int col_BKing = 4;
	
	
	@FXML
	private ImageView WPawn1;
	private double xwPawn1;
	private double ywPawn1;
	private int line_WPawn1 = 6;
	private int col_WPawn1 = 0;
	@FXML
	private ImageView WPawn2;
	private double xwPawn2;
	private double ywPawn2;
	private int line_WPawn2 = 6;
	private int col_WPawn2 = 1;
	@FXML
	private ImageView WPawn3;
	private double xwPawn3;
	private double ywPawn3;
	private int line_WPawn3 = 6;
	private int col_WPawn3 = 2;
	@FXML
	private ImageView WPawn4;
	private double xwPawn4;
	private double ywPawn4;
	private int line_WPawn4 = 6;
	private int col_WPawn4 = 3;
	@FXML
	private ImageView WPawn5;
	private double xwPawn5;
	private double ywPawn5;
	private int line_WPawn5 = 6;
	private int col_WPawn5 = 4;
	@FXML
	private ImageView WPawn6;
	private double xwPawn6;
	private double ywPawn6;
	private int line_WPawn6 = 6;
	private int col_WPawn6 = 5;
	@FXML
	private ImageView WPawn7;
	private double xwPawn7;
	private double ywPawn7;
	private int line_WPawn7 = 6;
	private int col_WPawn7 = 6;
	@FXML
	private ImageView WPawn8;
	private double xwPawn8;
	private double ywPawn8;
	private int line_WPawn8 = 6;
	private int col_WPawn8 = 7;
	
	@FXML
	private ImageView BPawn1;
	private double xbPawn1;
	private double ybPawn1;
	private int line_BPawn1 = 1;
	private int col_BPawn1 = 0;
	@FXML
	private ImageView BPawn2;
	private double xbPawn2;
	private double ybPawn2;
	private int line_BPawn2 = 1;
	private int col_BPawn2 = 1;
	@FXML
	private ImageView BPawn3;
	private double xbPawn3;
	private double ybPawn3;
	private int line_BPawn3 = 1;
	private int col_BPawn3 = 2;
	@FXML
	private ImageView BPawn4;
	private double xbPawn4;
	private double ybPawn4;
	private int line_BPawn4 = 1;
	private int col_BPawn4 = 3;
	@FXML
	private ImageView BPawn5;
	private double xbPawn5;
	private double ybPawn5;
	private int line_BPawn5 = 1;
	private int col_BPawn5 = 4;
	@FXML
	private ImageView BPawn6;
	private double xbPawn6;
	private double ybPawn6;
	private int line_BPawn6 = 1;
	private int col_BPawn6 = 5;
	@FXML
	private ImageView BPawn7;
	private double xbPawn7;
	private double ybPawn7;
	private int line_BPawn7 = 1;
	private int col_BPawn7 = 6;
	@FXML
	private ImageView BPawn8;
	private double xbPawn8;
	private double ybPawn8;
	private int line_BPawn8 = 1;
	private int col_BPawn8 = 7;
	
	public void follow_WRook1(MouseEvent e) {
		WRook1.setLayoutX(xwRook1 = e.getSceneX()-(87.5/2));
		WRook1.setLayoutY(ywRook1 = e.getSceneY()-(87.5/2));
		WRook1.toFront();
		WRook1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WRook2(MouseEvent e) {
		WRook2.setLayoutX(xwRook2 = e.getSceneX()-(87.5/2));
		WRook2.setLayoutY(ywRook2 = e.getSceneY()-(87.5/2));
		WRook2.toFront();
		WRook2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BRook1(MouseEvent e) {
		BRook1.setLayoutX(xbRook1 = e.getSceneX()-(87.5/2));
		BRook1.setLayoutY(ybRook1 = e.getSceneY()-(87.5/2));
		BRook1.toFront();
		BRook1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BRook2(MouseEvent e) {
		BRook2.setLayoutX(xbRook2 = e.getSceneX()-(87.5/2));
		BRook2.setLayoutY(ybRook2 = e.getSceneY()-(87.5/2));
		BRook2.toFront();
		BRook2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKnight1(MouseEvent e) {
		WKnight1.setLayoutX(xwKnight1 = e.getSceneX()-(87.5/2));
		WKnight1.setLayoutY(ywKnight1 = e.getSceneY()-(87.5/2));
		WKnight1.toFront();
		WKnight1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKnight2(MouseEvent e) {
		WKnight2.setLayoutX(xwKnight2 = e.getSceneX()-(87.5/2));
		WKnight2.setLayoutY(ywKnight2 = e.getSceneY()-(87.5/2));
		WKnight2.toFront();
		WKnight2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKnight1(MouseEvent e) {
		BKnight1.setLayoutX(xbKnight1 = e.getSceneX()-(87.5/2));
		BKnight1.setLayoutY(ybKnight1 = e.getSceneY()-(87.5/2));
		BKnight1.toFront();
		BKnight1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKnight2(MouseEvent e) {
		BKnight2.setLayoutX(xbKnight2 = e.getSceneX()-(87.5/2));
		BKnight2.setLayoutY(ybKnight2 = e.getSceneY()-(87.5/2));
		BKnight2.toFront();
		BKnight2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WBishop1(MouseEvent e) {
		WBishop1.setLayoutX(xwBishop1 = e.getSceneX()-(87.5/2));
		WBishop1.setLayoutY(ywBishop1 = e.getSceneY()-(87.5/2));
		WBishop1.toFront();
		WBishop1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WBishop2(MouseEvent e) {
		WBishop2.setLayoutX(xwBishop2 = e.getSceneX()-(87.5/2));
		WBishop2.setLayoutY(ywBishop2 = e.getSceneY()-(87.5/2));
		WBishop2.toFront();
		WBishop2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BBishop1(MouseEvent e) {
		BBishop1.setLayoutX(xbBishop1 = e.getSceneX()-(87.5/2));
		BBishop1.setLayoutY(ybBishop1 = e.getSceneY()-(87.5/2));
		BBishop1.toFront();
		BBishop1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BBishop2(MouseEvent e) {
		BBishop2.setLayoutX(xbBishop2 = e.getSceneX()-(87.5/2));
		BBishop2.setLayoutY(ybBishop2 = e.getSceneY()-(87.5/2));
		BBishop2.toFront();
		BBishop2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WQueen(MouseEvent e) {
		WQueen.setLayoutX(xwQueen = e.getSceneX()-(87.5/2));
		WQueen.setLayoutY(ywQueen = e.getSceneY()-(87.5/2));
		WQueen.toFront();
		WQueen.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BQueen(MouseEvent e) {
		BQueen.setLayoutX(xbQueen = e.getSceneX()-(87.5/2));
		BQueen.setLayoutY(ybQueen = e.getSceneY()-(87.5/2));
		BQueen.toFront();
		BQueen.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKing(MouseEvent e) {
		WKing.setLayoutX(xwKing = e.getSceneX()-(87.5/2));
		WKing.setLayoutY(ywKing = e.getSceneY()-(87.5/2));
		WKing.toFront();
		WKing.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKing(MouseEvent e) {
		BKing.setLayoutX(xbKing = e.getSceneX()-(87.5/2));
		BKing.setLayoutY(ybKing = e.getSceneY()-(87.5/2));
		BKing.toFront();
		BKing.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn1(MouseEvent e) {
		WPawn1.setLayoutX(xwPawn1 = e.getSceneX()-(87.5/2));
		WPawn1.setLayoutY(ywPawn1 = e.getSceneY()-(87.5/2));
		WPawn1.toFront();
		WPawn1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn2(MouseEvent e) {
		WPawn2.setLayoutX(xwPawn2 = e.getSceneX()-(87.5/2));
		WPawn2.setLayoutY(ywPawn2 = e.getSceneY()-(87.5/2));
		WPawn2.toFront();
		WPawn2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn3(MouseEvent e) {
		WPawn3.setLayoutX(xwPawn3 = e.getSceneX()-(87.5/2));
		WPawn3.setLayoutY(ywPawn3 = e.getSceneY()-(87.5/2));
		WPawn3.toFront();
		WPawn3.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn4(MouseEvent e) {
		WPawn4.setLayoutX(xwPawn4 = e.getSceneX()-(87.5/2));
		WPawn4.setLayoutY(ywPawn4 = e.getSceneY()-(87.5/2));
		WPawn4.toFront();
		WPawn4.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn5(MouseEvent e) {
		WPawn5.setLayoutX(xwPawn5 = e.getSceneX()-(87.5/2));
		WPawn5.setLayoutY(ywPawn5 = e.getSceneY()-(87.5/2));
		WPawn5.toFront();
		WPawn5.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn6(MouseEvent e) {
		WPawn6.setLayoutX(xwPawn6 = e.getSceneX()-(87.5/2));
		WPawn6.setLayoutY(ywPawn6 = e.getSceneY()-(87.5/2));
		WPawn6.toFront();
		WPawn6.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn7(MouseEvent e) {
		WPawn7.setLayoutX(xwPawn7 = e.getSceneX()-(87.5/2));
		WPawn7.setLayoutY(ywPawn7 = e.getSceneY()-(87.5/2));
		WPawn7.toFront();
		WPawn7.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn8(MouseEvent e) {
		WPawn8.setLayoutX(xwPawn8 = e.getSceneX()-(87.5/2));
		WPawn8.setLayoutY(ywPawn8 = e.getSceneY()-(87.5/2));
		WPawn8.toFront();
		WPawn8.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn1(MouseEvent e) {
		BPawn1.setLayoutX(xbPawn1 = e.getSceneX()-(87.5/2));
		BPawn1.setLayoutY(ybPawn1 = e.getSceneY()-(87.5/2));
		BPawn1.toFront();
		BPawn1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn2(MouseEvent e) {
		BPawn2.setLayoutX(xbPawn2 = e.getSceneX()-(87.5/2));
		BPawn2.setLayoutY(ybPawn2 = e.getSceneY()-(87.5/2));
		BPawn2.toFront();
		BPawn2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn3(MouseEvent e) {
		BPawn3.setLayoutX(xbPawn3 = e.getSceneX()-(87.5/2));
		BPawn3.setLayoutY(ybPawn3 = e.getSceneY()-(87.5/2));
		BPawn3.toFront();
		BPawn3.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn4(MouseEvent e) {
		BPawn4.setLayoutX(xbPawn4 = e.getSceneX()-(87.5/2));
		BPawn4.setLayoutY(ybPawn4 = e.getSceneY()-(87.5/2));
		BPawn4.toFront();
		BPawn4.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn5(MouseEvent e) {
		BPawn5.setLayoutX(xbPawn5 = e.getSceneX()-(87.5/2));
		BPawn5.setLayoutY(ybPawn5 = e.getSceneY()-(87.5/2));
		BPawn5.toFront();
		BPawn5.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn6(MouseEvent e) {
		BPawn6.setLayoutX(xbPawn6 = e.getSceneX()-(87.5/2));
		BPawn6.setLayoutY(ybPawn6 = e.getSceneY()-(87.5/2));
		BPawn6.toFront();
		BPawn6.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn7(MouseEvent e) {
		BPawn7.setLayoutX(xbPawn7 = e.getSceneX()-(87.5/2));
		BPawn7.setLayoutY(ybPawn7 = e.getSceneY()-(87.5/2));
		BPawn7.toFront();
		BPawn7.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn8(MouseEvent e) {
		BPawn8.setLayoutX(xbPawn8 = e.getSceneX()-(87.5/2));
		BPawn8.setLayoutY(ybPawn8 = e.getSceneY()-(87.5/2));
		BPawn8.toFront();
		BPawn8.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void possibleMoves(MouseEvent e) {
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		HashSet<Short> moves = RunningGUI.gameBoard.board[i][j].legalMoves(RunningGUI.gameBoard, i, j);
		if (listCircle.size() == 0) {
			this.setList();
		}
		for (int k=0; k<8; k++) {
			for (int l=0; l<8; l++) {
				if (moves.contains((Object)((short)(10*k+l)))) {
					double opacity = listCircle.get(8*k+l).getOpacity();
					if (opacity == 0) {
						listCircle.get(8*k+l).toFront();
					} else {
						listCircle.get(8*k+l).toBack();
					}
					listCircle.get(8*k+l).setOpacity(0.5-opacity);

				}
			}
		}
	}
	
	public void move_WRook1(MouseEvent e) {
		WRook1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WRook1.toFront();
			RunningGUI.gameBoard.board[line_WRook1][col_WRook1].movePiece(RunningGUI.gameBoard, 
					line_WRook1, col_WRook1, i, j);
			this.reactIfCapture(i, j);
			line_WRook1 = i;
			col_WRook1 = j;
			WRook1.setLayoutX(xwRook1 = col_WRook1*(700/8+0.5));
			WRook1.setLayoutY(ywRook1 = line_WRook1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WRook1.setLayoutX(xwRook1 = col_WRook1*(700/8+0.5));
			WRook1.setLayoutY(ywRook1 = line_WRook1*(700/8+0.5));
		}
	}
	
	public void move_WRook2(MouseEvent e) {
		WRook2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WRook2.toFront();
			RunningGUI.gameBoard.board[line_WRook2][col_WRook2].movePiece(RunningGUI.gameBoard, 
					line_WRook2, col_WRook2, i, j);
			this.reactIfCapture(i, j);
			line_WRook2 = i;
			col_WRook2 = j;
			WRook2.setLayoutX(xwRook2 = col_WRook2*(700/8+0.5));
			WRook2.setLayoutY(ywRook2 = line_WRook2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WRook2.setLayoutX(xwRook2 = col_WRook2*(700/8+0.5));
			WRook2.setLayoutY(ywRook2 = line_WRook2*(700/8+0.5));
		}
	}
	
	public void move_BRook1(MouseEvent e) {
		BRook1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BRook1.toFront();
			RunningGUI.gameBoard.board[line_BRook1][col_BRook1].movePiece(RunningGUI.gameBoard, 
					line_BRook1, col_BRook1, i, j);
			this.reactIfCapture(i, j);
			line_BRook1 = i;
			col_BRook1 = j;
			BRook1.setLayoutX(xbRook1 = col_BRook1*(700/8+0.5));
			BRook1.setLayoutY(ybRook1 = line_BRook1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BRook1.setLayoutX(xbRook1 = col_BRook1*(700/8+0.5));
			BRook1.setLayoutY(ybRook1 = line_BRook1*(700/8+0.5));
		}
	}
	
	public void move_BRook2(MouseEvent e) {
		BRook2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BRook2.toFront();
			RunningGUI.gameBoard.board[line_BRook2][col_BRook2].movePiece(RunningGUI.gameBoard, 
					line_BRook2, col_BRook2, i, j);
			this.reactIfCapture(i, j);
			line_BRook2 = i;
			col_BRook2 = j;
			BRook2.setLayoutX(xbRook2 = col_BRook2*(700/8+0.5));
			BRook2.setLayoutY(ybRook2 = line_BRook2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BRook2.setLayoutX(xbRook2 = col_BRook2*(700/8+0.5));
			BRook2.setLayoutY(ybRook2 = line_BRook2*(700/8+0.5));
		}
	}

	
	public void move_WKnight1(MouseEvent e) {
		WKnight1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKnight1.toFront();
			RunningGUI.gameBoard.board[line_WKnight1][col_WKnight1].movePiece(RunningGUI.gameBoard, 
					line_WKnight1, col_WKnight1, i, j);
			this.reactIfCapture(i, j);
			line_WKnight1 = i;
			col_WKnight1 = j;
			WKnight1.setLayoutX(xwKnight1 = col_WKnight1*(700/8+0.5));
			WKnight1.setLayoutY(ywKnight1 = line_WKnight1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKnight1.setLayoutX(xwKnight1 = col_WKnight1*(700/8+0.5));
			WKnight1.setLayoutY(ywKnight1 = line_WKnight1*(700/8+0.5));
		}
	}
	
	public void move_WKnight2(MouseEvent e) {
		WKnight2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKnight2.toFront();
			RunningGUI.gameBoard.board[line_WKnight2][col_WKnight2].movePiece(RunningGUI.gameBoard, 
					line_WKnight2, col_WKnight2, i, j);
			this.reactIfCapture(i, j);
			line_WKnight2 = i;
			col_WKnight2 = j;
			WKnight2.setLayoutX(xwKnight2 = col_WKnight2*(700/8+0.5));
			WKnight2.setLayoutY(ywKnight2 = line_WKnight2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKnight2.setLayoutX(xwKnight2 = col_WKnight2*(700/8+0.5));
			WKnight2.setLayoutY(ywKnight2 = line_WKnight2*(700/8+0.5));
		}
	}
	
	public void move_BKnight1(MouseEvent e) {
		BKnight1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKnight1.toFront();
			RunningGUI.gameBoard.board[line_BKnight1][col_BKnight1].movePiece(RunningGUI.gameBoard, 
					line_BKnight1, col_BKnight1, i, j);
			this.reactIfCapture(i, j);
			line_BKnight1 = i;
			col_BKnight1 = j;
			BKnight1.setLayoutX(xbKnight1 = col_BKnight1*(700/8+0.5));
			BKnight1.setLayoutY(ybKnight1 = line_BKnight1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKnight1.setLayoutX(xbKnight1 = col_BKnight1*(700/8+0.5));
			BKnight1.setLayoutY(ybKnight1 = line_BKnight1*(700/8+0.5));
		}
	}
	
	public void move_BKnight2(MouseEvent e) {
		BKnight2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKnight2.toFront();
			RunningGUI.gameBoard.board[line_BKnight2][col_BKnight2].movePiece(RunningGUI.gameBoard, 
					line_BKnight2, col_BKnight2, i, j);
			this.reactIfCapture(i, j);
			line_BKnight2 = i;
			col_BKnight2 = j;
			BKnight2.setLayoutX(xbKnight2 = col_BKnight2*(700/8+0.5));
			BKnight2.setLayoutY(ybKnight2 = line_BKnight2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKnight2.setLayoutX(xbKnight2 = col_BKnight2*(700/8+0.5));
			BKnight2.setLayoutY(ybKnight2 = line_BKnight2*(700/8+0.5));
		}
	}
	
	public void move_WBishop1(MouseEvent e) {
		WBishop1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WBishop1.toFront();
			RunningGUI.gameBoard.board[line_WBishop1][col_WBishop1].movePiece(RunningGUI.gameBoard, 
					line_WBishop1, col_WBishop1, i, j);
			this.reactIfCapture(i, j);
			line_WBishop1 = i;
			col_WBishop1 = j;
			WBishop1.setLayoutX(xwBishop1 = col_WBishop1*(700/8+0.5));
			WBishop1.setLayoutY(ywBishop1 = line_WBishop1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WBishop1.setLayoutX(xwBishop1 = col_WBishop1*(700/8+0.5));
			WBishop1.setLayoutY(ywBishop1 = line_WBishop1*(700/8+0.5));
		}
	}
	
	public void move_WBishop2(MouseEvent e) {
		WBishop2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WBishop2.toFront();
			RunningGUI.gameBoard.board[line_WBishop2][col_WBishop2].movePiece(RunningGUI.gameBoard, 
					line_WBishop2, col_WBishop2, i, j);
			this.reactIfCapture(i, j);
			line_WBishop2 = i;
			col_WBishop2 = j;
			WBishop2.setLayoutX(xwBishop2 = col_WBishop2*(700/8+0.5));
			WBishop2.setLayoutY(ywBishop2 = line_WBishop2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WBishop2.setLayoutX(xwBishop2 = col_WBishop2*(700/8+0.5));
			WBishop2.setLayoutY(ywBishop2 = line_WBishop2*(700/8+0.5));
		}
	}
	
	public void move_BBishop1(MouseEvent e) {
		BBishop1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BBishop1.toFront();
			RunningGUI.gameBoard.board[line_BBishop1][col_BBishop1].movePiece(RunningGUI.gameBoard, 
					line_BBishop1, col_BBishop1, i, j);
			this.reactIfCapture(i, j);
			line_BBishop1 = i;
			col_BBishop1 = j;
			BBishop1.setLayoutX(xbBishop1 = col_BBishop1*(700/8+0.5));
			BBishop1.setLayoutY(ybBishop1 = line_BBishop1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BBishop1.setLayoutX(xbBishop1 = col_BBishop1*(700/8+0.5));
			BBishop1.setLayoutY(ybBishop1 = line_BBishop1*(700/8+0.5));
		}
	}
	
	public void move_BBishop2(MouseEvent e) {
		BBishop2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BBishop2.toFront();
			RunningGUI.gameBoard.board[line_BBishop2][col_BBishop2].movePiece(RunningGUI.gameBoard, 
					line_BBishop2, col_BBishop2, i, j);
			this.reactIfCapture(i, j);
			line_BBishop2 = i;
			col_BBishop2 = j;
			BBishop2.setLayoutX(xbBishop2 = col_BBishop2*(700/8+0.5));
			BBishop2.setLayoutY(ybBishop2 = line_BBishop2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BBishop2.setLayoutX(xbBishop2 = col_BBishop2*(700/8+0.5));
			BBishop2.setLayoutY(ybBishop2 = line_BBishop2*(700/8+0.5));
		}
	}
	
	public void move_WQueen(MouseEvent e) {
		WQueen.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WQueen.toFront();
			RunningGUI.gameBoard.board[line_WQueen][col_WQueen].movePiece(RunningGUI.gameBoard, 
					line_WQueen, col_WQueen, i, j);
			this.reactIfCapture(i, j);
			line_WQueen = i;
			col_WQueen = j;
			WQueen.setLayoutX(xwQueen = col_WQueen*(700/8+0.5));
			WQueen.setLayoutY(ywQueen = line_WQueen*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WQueen.setLayoutX(xwQueen = col_WQueen*(700/8+0.5));
			WQueen.setLayoutY(ywQueen = line_WQueen*(700/8+0.5));
		}
	}
	
	public void move_BQueen(MouseEvent e) {
		BQueen.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BQueen.toFront();
			RunningGUI.gameBoard.board[line_BQueen][col_BQueen].movePiece(RunningGUI.gameBoard, 
					line_BQueen, col_BQueen, i, j);
			this.reactIfCapture(i, j);
			line_BQueen = i;
			col_BQueen = j;
			BQueen.setLayoutX(xbQueen = col_BQueen*(700/8+0.5));
			BQueen.setLayoutY(ybQueen = line_BQueen*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BQueen.setLayoutX(xbQueen = col_BQueen*(700/8+0.5));
			BQueen.setLayoutY(ybQueen = line_BQueen*(700/8+0.5));
		}
	}
	
	public void move_WKing(MouseEvent e) {
		WKing.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKing.toFront();
			RunningGUI.gameBoard.board[line_WKing][col_WKing].movePiece(RunningGUI.gameBoard, 
					line_WKing, col_WKing, i, j);
			this.reactIfCapture(i, j);
			line_WKing = i;
			col_WKing = j;
			WKing.setLayoutX(xwKing = col_WKing*(700/8+0.5));
			WKing.setLayoutY(ywKing = line_WKing*(700/8+0.5));
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.KingSideCastle) {
				WRook2.setLayoutX(xwRook2 = 5*(700/8+0.5));
				WRook2.setLayoutY(ywRook2 = 7*(700/8+0.5));
				line_WRook2 = 7;
				col_WRook2 = 5;
			}
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.QueenSideCastle) {
				WRook1.setLayoutX(xwRook1 = 3*(700/8+0.5));
				WRook1.setLayoutY(ywRook1 = 7*(700/8+0.5));
				line_WRook1 = 7;
				col_WRook1 = 3;
			}
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKing.setLayoutX(xwKing = col_WKing*(700/8+0.5));
			WKing.setLayoutY(ywKing = line_WKing*(700/8+0.5));
		}
	}
	
	public void move_BKing(MouseEvent e) {
		BKing.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKing.toFront();
			RunningGUI.gameBoard.board[line_BKing][col_BKing].movePiece(RunningGUI.gameBoard, 
					line_BKing, col_BKing, i, j);
			this.reactIfCapture(i, j);
			line_BKing = i;
			col_BKing = j;
			BKing.setLayoutX(xbKing = col_BKing*(700/8+0.5));
			BKing.setLayoutY(ybKing = line_BKing*(700/8+0.5));
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.KingSideCastle) {
				BRook2.setLayoutX(xbRook2 = 5*(700/8+0.5));
				BRook2.setLayoutY(ybRook2 = 0*(700/8+0.5));
				line_BRook2 = 0;
				col_BRook2 = 5;
			}
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.QueenSideCastle) {
				BRook1.setLayoutX(xbRook1 = 3*(700/8+0.5));
				BRook1.setLayoutY(ybRook1 = 0*(700/8+0.5));
				line_BRook1 = 0;
				col_BRook1 = 3;
			}
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKing.setLayoutX(xbKing = col_BKing*(700/8+0.5));
			BKing.setLayoutY(ybKing = line_BKing*(700/8+0.5));
		}
	}
	
	public void move_WPawn1(MouseEvent e) {
		WPawn1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn1.toFront();
			RunningGUI.gameBoard.board[line_WPawn1][col_WPawn1].movePiece(RunningGUI.gameBoard, 
					line_WPawn1, col_WPawn1, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn1.setImage(White_queen);
			}
			line_WPawn1 = i;
			col_WPawn1 = j;
			WPawn1.setLayoutX(xwPawn1 = col_WPawn1*(700/8+0.5));
			WPawn1.setLayoutY(ywPawn1 = line_WPawn1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn1.setLayoutX(xwPawn1 = col_WPawn1*(700/8+0.5));
			WPawn1.setLayoutY(ywPawn1 = line_WPawn1*(700/8+0.5));
		}
	}
	
	public void move_WPawn2(MouseEvent e) {
		WPawn2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn2.toFront();
			RunningGUI.gameBoard.board[line_WPawn2][col_WPawn2].movePiece(RunningGUI.gameBoard, 
					line_WPawn2, col_WPawn2, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn2.setImage(White_queen);
			}
			line_WPawn2 = i;
			col_WPawn2 = j;
			WPawn2.setLayoutX(xwPawn2 = col_WPawn2*(700/8+0.5));
			WPawn2.setLayoutY(ywPawn2 = line_WPawn2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn2.setLayoutX(xwPawn2 = col_WPawn2*(700/8+0.5));
			WPawn2.setLayoutY(ywPawn2 = line_WPawn2*(700/8+0.5));
		}
	}
	
	public void move_WPawn3(MouseEvent e) {
		WPawn3.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn3.toFront();
			RunningGUI.gameBoard.board[line_WPawn3][col_WPawn3].movePiece(RunningGUI.gameBoard, 
					line_WPawn3, col_WPawn3, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn3.setImage(White_queen);
			}
			line_WPawn3 = i;
			col_WPawn3 = j;
			WPawn3.setLayoutX(xwPawn3 = col_WPawn3*(700/8+0.5));
			WPawn3.setLayoutY(ywPawn3 = line_WPawn3*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn3.setLayoutX(xwPawn3 = col_WPawn3*(700/8+0.5));
			WPawn3.setLayoutY(ywPawn3 = line_WPawn3*(700/8+0.5));
		}
	}
	
	public void move_WPawn4(MouseEvent e) {
		WPawn4.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn4.toFront();
			RunningGUI.gameBoard.board[line_WPawn4][col_WPawn4].movePiece(RunningGUI.gameBoard, 
					line_WPawn4, col_WPawn4, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn4.setImage(White_queen);
			}
			line_WPawn4 = i;
			col_WPawn4 = j;
			WPawn4.setLayoutX(xwPawn4 = col_WPawn4*(700/8+0.5));
			WPawn4.setLayoutY(ywPawn4 = line_WPawn4*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn4.setLayoutX(xwPawn4 = col_WPawn4*(700/8+0.5));
			WPawn4.setLayoutY(ywPawn4 = line_WPawn4*(700/8+0.5));
		}
	}
	
	public void move_WPawn5(MouseEvent e) {
		WPawn5.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn5.toFront();
			RunningGUI.gameBoard.board[line_WPawn5][col_WPawn5].movePiece(RunningGUI.gameBoard, 
					line_WPawn5, col_WPawn5, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn5.setImage(White_queen);
			}
			line_WPawn5 = i;
			col_WPawn5 = j;
			WPawn5.setLayoutX(xwPawn5 = col_WPawn5*(700/8+0.5));
			WPawn5.setLayoutY(ywPawn5 = line_WPawn5*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn5.setLayoutX(xwPawn5 = col_WPawn5*(700/8+0.5));
			WPawn5.setLayoutY(ywPawn5 = line_WPawn5*(700/8+0.5));
		}
	}

	public void move_WPawn6(MouseEvent e) {
		WPawn6.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn6.toFront();
			RunningGUI.gameBoard.board[line_WPawn6][col_WPawn6].movePiece(RunningGUI.gameBoard, 
					line_WPawn6, col_WPawn6, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn6.setImage(White_queen);
			}
			line_WPawn6 = i;
			col_WPawn6 = j;
			WPawn6.setLayoutX(xwPawn6 = col_WPawn6*(700/8+0.5));
			WPawn6.setLayoutY(ywPawn6 = line_WPawn6*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn6.setLayoutX(xwPawn6 = col_WPawn6*(700/8+0.5));
			WPawn6.setLayoutY(ywPawn6 = line_WPawn6*(700/8+0.5));
		}
	}
	
	public void move_WPawn7(MouseEvent e) {
		WPawn7.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn7.toFront();
			RunningGUI.gameBoard.board[line_WPawn7][col_WPawn7].movePiece(RunningGUI.gameBoard, 
					line_WPawn7, col_WPawn7, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn7.setImage(White_queen);
			}
			line_WPawn7 = i;
			col_WPawn7 = j;
			WPawn7.setLayoutX(xwPawn7 = col_WPawn7*(700/8+0.5));
			WPawn7.setLayoutY(ywPawn7 = line_WPawn7*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn7.setLayoutX(xwPawn7 = col_WPawn7*(700/8+0.5));
			WPawn7.setLayoutY(ywPawn7 = line_WPawn7*(700/8+0.5));
		}
	}
	
	public void move_WPawn8(MouseEvent e) {
		WPawn8.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn8.toFront();
			RunningGUI.gameBoard.board[line_WPawn8][col_WPawn8].movePiece(RunningGUI.gameBoard, 
					line_WPawn8, col_WPawn8, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn8.setImage(White_queen);
			}
			line_WPawn8 = i;
			col_WPawn8 = j;
			WPawn8.setLayoutX(xwPawn8 = col_WPawn8*(700/8+0.5));
			WPawn8.setLayoutY(ywPawn8 = line_WPawn8*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn8.setLayoutX(xwPawn8 = col_WPawn8*(700/8+0.5));
			WPawn8.setLayoutY(ywPawn8 = line_WPawn8*(700/8+0.5));
		}
	}
	
	public void move_BPawn1(MouseEvent e) {
		BPawn1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn1.toFront();
			RunningGUI.gameBoard.board[line_BPawn1][col_BPawn1].movePiece(RunningGUI.gameBoard, 
					line_BPawn1, col_BPawn1, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn1.setImage(Black_queen);
			}
			line_BPawn1 = i;
			col_BPawn1 = j;
			BPawn1.setLayoutX(xbPawn1 = col_BPawn1*(700/8+0.5));
			BPawn1.setLayoutY(ybPawn1 = line_BPawn1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn1.setLayoutX(xbPawn1 = col_BPawn1*(700/8+0.5));
			BPawn1.setLayoutY(ybPawn1 = line_BPawn1*(700/8+0.5));
		}
	}
	
	public void move_BPawn2(MouseEvent e) {
		BPawn2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn2.toFront();
			RunningGUI.gameBoard.board[line_BPawn2][col_BPawn2].movePiece(RunningGUI.gameBoard, 
					line_BPawn2, col_BPawn2, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn2.setImage(Black_queen);
			}
			line_BPawn2 = i;
			col_BPawn2 = j;
			BPawn2.setLayoutX(xbPawn2 = col_BPawn2*(700/8+0.5));
			BPawn2.setLayoutY(ybPawn2 = line_BPawn2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn2.setLayoutX(xbPawn2 = col_BPawn2*(700/8+0.5));
			BPawn2.setLayoutY(ybPawn2 = line_BPawn2*(700/8+0.5));
		}
	}
	
	public void move_BPawn3(MouseEvent e) {
		BPawn3.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn3.toFront();
			RunningGUI.gameBoard.board[line_BPawn3][col_BPawn3].movePiece(RunningGUI.gameBoard, 
					line_BPawn3, col_BPawn3, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn3.setImage(Black_queen);
			}
			line_BPawn3 = i;
			col_BPawn3 = j;
			BPawn3.setLayoutX(xbPawn3 = col_BPawn3*(700/8+0.5));
			BPawn3.setLayoutY(ybPawn3 = line_BPawn3*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn3.setLayoutX(xbPawn3 = col_BPawn3*(700/8+0.5));
			BPawn3.setLayoutY(ybPawn3 = line_BPawn3*(700/8+0.5));
		}
	}
	
	public void move_BPawn4(MouseEvent e) {
		BPawn4.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn4.toFront();
			RunningGUI.gameBoard.board[line_BPawn4][col_BPawn4].movePiece(RunningGUI.gameBoard, 
					line_BPawn4, col_BPawn4, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn4.setImage(Black_queen);
			}
			line_BPawn4 = i;
			col_BPawn4 = j;
			BPawn4.setLayoutX(xbPawn4 = col_BPawn4*(700/8+0.5));
			BPawn4.setLayoutY(ybPawn4 = line_BPawn4*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn4.setLayoutX(xbPawn4 = col_BPawn4*(700/8+0.5));
			BPawn4.setLayoutY(ybPawn4 = line_BPawn4*(700/8+0.5));
		}
	}
	
	public void move_BPawn5(MouseEvent e) {
		BPawn5.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn5.toFront();
			RunningGUI.gameBoard.board[line_BPawn5][col_BPawn5].movePiece(RunningGUI.gameBoard, 
					line_BPawn5, col_BPawn5, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn5.setImage(Black_queen);
			}
			line_BPawn5 = i;
			col_BPawn5 = j;
			BPawn5.setLayoutX(xbPawn5 = col_BPawn5*(700/8+0.5));
			BPawn5.setLayoutY(ybPawn5 = line_BPawn5*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn5.setLayoutX(xbPawn5 = col_BPawn5*(700/8+0.5));
			BPawn5.setLayoutY(ybPawn5 = line_BPawn5*(700/8+0.5));
		}
	}

	public void move_BPawn6(MouseEvent e) {
		BPawn6.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn6.toFront();
			RunningGUI.gameBoard.board[line_BPawn6][col_BPawn6].movePiece(RunningGUI.gameBoard, 
					line_BPawn6, col_BPawn6, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn6.setImage(Black_queen);
			}
			line_BPawn6 = i;
			col_BPawn6 = j;
			BPawn6.setLayoutX(xbPawn6 = col_BPawn6*(700/8+0.5));
			BPawn6.setLayoutY(ybPawn6 = line_BPawn6*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn6.setLayoutX(xbPawn6 = col_BPawn6*(700/8+0.5));
			BPawn6.setLayoutY(ybPawn6 = line_BPawn6*(700/8+0.5));
		}
	}
	
	public void move_BPawn7(MouseEvent e) {
		BPawn7.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn7.toFront();
			RunningGUI.gameBoard.board[line_BPawn7][col_BPawn7].movePiece(RunningGUI.gameBoard, 
					line_BPawn7, col_BPawn7, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn8.setImage(Black_queen);
			}
			line_BPawn7 = i;
			col_BPawn7 = j;
			BPawn7.setLayoutX(xbPawn7 = col_BPawn7*(700/8+0.5));
			BPawn7.setLayoutY(ybPawn7 = line_BPawn7*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn7.setLayoutX(xbPawn7 = col_BPawn7*(700/8+0.5));
			BPawn7.setLayoutY(ybPawn7 = line_BPawn7*(700/8+0.5));
		}
	}
	
	public void move_BPawn8(MouseEvent e) {
		BPawn8.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn8.toFront();
			RunningGUI.gameBoard.board[line_BPawn8][col_BPawn8].movePiece(RunningGUI.gameBoard, 
					line_BPawn8, col_BPawn8, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn8.setImage(Black_queen);
			}
			line_BPawn8 = i;
			col_BPawn8 = j;
			BPawn8.setLayoutX(xbPawn8 = col_BPawn8*(700/8+0.5));
			BPawn8.setLayoutY(ybPawn8 = line_BPawn8*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn8.setLayoutX(xbPawn8 = col_BPawn8*(700/8+0.5));
			BPawn8.setLayoutY(ybPawn8 = line_BPawn8*(700/8+0.5));
		}
	}
	
	public void movePiece(double line, double col) {
		WPawn1.setLayoutX(500);
		WPawn1.setLayoutY(500);
	}
	
	public ImageView getPieceOnCoordinate(double col, double line) {
		double j = col*(700/8+0.5);
		double i = line*(700/8+0.5);
		if (WRook1.getLayoutX() == i && WRook1.getLayoutY() == j) {
			return WRook1;
		}
		if (WRook2.getLayoutX() == i && WRook2.getLayoutY() == j) {
			return WRook2;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (WKnight1.getLayoutX() == i && WKnight1.getLayoutY() == j) {
			return WKnight1;
		}
		if (WKnight2.getLayoutX() == i && WKnight2.getLayoutY() == j) {
			return WKnight2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (WBishop1.getLayoutX() == i && WBishop1.getLayoutY() == j) {
			return WBishop1;
		}
		if (WBishop2.getLayoutX() == i && WBishop2.getLayoutY() == j) {
			return WBishop2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (WQueen.getLayoutX() == i && WQueen.getLayoutY() == j) {
			return WQueen;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (WKing.getLayoutX() == i && WKing.getLayoutY() == j) {
			return WKing;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (WPawn1.getLayoutX() == i && WPawn1.getLayoutY() == j) {
			return WPawn1;
		}
		if (WPawn2.getLayoutX() == i && WPawn2.getLayoutY() == j) {
			return WPawn2;
		}
		if (WPawn3.getLayoutX() == i && WPawn3.getLayoutY() == j) {
			return WPawn3;
		}
		if (WPawn4.getLayoutX() == i && WPawn4.getLayoutY() == j) {
			return WPawn4;
		}
		if (WPawn5.getLayoutX() == i && WPawn5.getLayoutY() == j) {
			return WPawn5;
		}
		if (WPawn6.getLayoutX() == i && WPawn6.getLayoutY() == j) {
			return WPawn6;
		}
		if (WPawn7.getLayoutX() == i && WPawn7.getLayoutY() == j) {
			return WPawn7;
		}
		if (WPawn8.getLayoutX() == i && WPawn8.getLayoutY() == j) {
			return WPawn8;
		}
		if (BPawn1.getLayoutX() == i && BPawn1.getLayoutY() == j) {
			return BPawn1;
		}
		if (BPawn2.getLayoutX() == i && BPawn2.getLayoutY() == j) {
			return BPawn2;
		}
		if (BPawn3.getLayoutX() == i && BPawn3.getLayoutY() == j) {
			return BPawn3;
		}
		if (BPawn4.getLayoutX() == i && BPawn4.getLayoutY() == j) {
			return BPawn4;
		}
		if (BPawn5.getLayoutX() == i && BPawn5.getLayoutY() == j) {
			return BPawn5;
		}
		if (BPawn6.getLayoutX() == i && BPawn6.getLayoutY() == j) {
			return BPawn6;
		}
		if (BPawn7.getLayoutX() == i && BPawn7.getLayoutY() == j) {
			return BPawn7;
		}
		if (BPawn8.getLayoutX() == i && BPawn8.getLayoutY() == j) {
			return BPawn8;
		}
		return null;
	}
	
	public void reactIfCapture(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	public void reactIfCaptureWPawn(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.EnPassant) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i+1, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		} else if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	public void reactIfCaptureBPawn(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.EnPassant) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i-1, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		} else if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	
	@FXML
	private Circle Circle00;
	@FXML
	private Circle Circle01;
	@FXML
	private Circle Circle02;
	@FXML
	private Circle Circle03;
	@FXML
	private Circle Circle04;
	@FXML
	private Circle Circle05;
	@FXML
	private Circle Circle06;
	@FXML
	private Circle Circle07;
	@FXML
	private Circle Circle10;
	@FXML
	private Circle Circle11;
	@FXML
	private Circle Circle12;
	@FXML
	private Circle Circle13;
	@FXML
	private Circle Circle14;
	@FXML
	private Circle Circle15;
	@FXML
	private Circle Circle16;
	@FXML
	private Circle Circle17;
	@FXML
	private Circle Circle20;
	@FXML
	private Circle Circle21;
	@FXML
	private Circle Circle22;
	@FXML
	private Circle Circle23;
	@FXML
	private Circle Circle24;
	@FXML
	private Circle Circle25;
	@FXML
	private Circle Circle26;
	@FXML
	private Circle Circle27;
	@FXML
	private Circle Circle30;
	@FXML
	private Circle Circle31;
	@FXML
	private Circle Circle32;
	@FXML
	private Circle Circle33;
	@FXML
	private Circle Circle34;
	@FXML
	private Circle Circle35;
	@FXML
	private Circle Circle36;
	@FXML
	private Circle Circle37;
	@FXML
	private Circle Circle40;
	@FXML
	private Circle Circle41;
	@FXML
	private Circle Circle42;
	@FXML
	private Circle Circle43;
	@FXML
	private Circle Circle44;
	@FXML
	private Circle Circle45;
	@FXML
	private Circle Circle46;
	@FXML
	private Circle Circle47;
	@FXML
	private Circle Circle50;
	@FXML
	private Circle Circle51;
	@FXML
	private Circle Circle52;
	@FXML
	private Circle Circle53;
	@FXML
	private Circle Circle54;
	@FXML
	private Circle Circle55;
	@FXML
	private Circle Circle56;
	@FXML
	private Circle Circle57;
	@FXML
	private Circle Circle60;
	@FXML
	private Circle Circle61;
	@FXML
	private Circle Circle62;
	@FXML
	private Circle Circle63;
	@FXML
	private Circle Circle64;
	@FXML
	private Circle Circle65;
	@FXML
	private Circle Circle66;
	@FXML
	private Circle Circle67;
	@FXML
	private Circle Circle70;
	@FXML
	private Circle Circle71;
	@FXML
	private Circle Circle72;
	@FXML
	private Circle Circle73;
	@FXML
	private Circle Circle74;
	@FXML
	private Circle Circle75;
	@FXML
	private Circle Circle76;
	@FXML
	private Circle Circle77;
	
	private List<Circle> listCircle = new ArrayList<Circle>();
	
	public void setList() {
		listCircle.add(Circle00);
		listCircle.add(Circle01);
		listCircle.add(Circle02);
		listCircle.add(Circle03);
		listCircle.add(Circle04);
		listCircle.add(Circle05);
		listCircle.add(Circle06);
		listCircle.add(Circle07);
		listCircle.add(Circle10);
		listCircle.add(Circle11);
		listCircle.add(Circle12);
		listCircle.add(Circle13);
		listCircle.add(Circle14);
		listCircle.add(Circle15);
		listCircle.add(Circle16);
		listCircle.add(Circle17);
		listCircle.add(Circle20);
		listCircle.add(Circle21);
		listCircle.add(Circle22);
		listCircle.add(Circle23);
		listCircle.add(Circle24);
		listCircle.add(Circle25);
		listCircle.add(Circle26);
		listCircle.add(Circle27);
		listCircle.add(Circle30);
		listCircle.add(Circle31);
		listCircle.add(Circle32);
		listCircle.add(Circle33);
		listCircle.add(Circle34);
		listCircle.add(Circle35);
		listCircle.add(Circle36);
		listCircle.add(Circle37);
		listCircle.add(Circle40);
		listCircle.add(Circle41);
		listCircle.add(Circle42);
		listCircle.add(Circle43);
		listCircle.add(Circle44);
		listCircle.add(Circle45);
		listCircle.add(Circle46);
		listCircle.add(Circle47);
		listCircle.add(Circle50);
		listCircle.add(Circle51);
		listCircle.add(Circle52);
		listCircle.add(Circle53);
		listCircle.add(Circle54);
		listCircle.add(Circle55);
		listCircle.add(Circle56);
		listCircle.add(Circle57);
		listCircle.add(Circle60);
		listCircle.add(Circle61);
		listCircle.add(Circle62);
		listCircle.add(Circle63);
		listCircle.add(Circle64);
		listCircle.add(Circle65);
		listCircle.add(Circle66);
		listCircle.add(Circle67);
		listCircle.add(Circle70);
		listCircle.add(Circle71);
		listCircle.add(Circle72);
		listCircle.add(Circle73);
		listCircle.add(Circle74);
		listCircle.add(Circle75);
		listCircle.add(Circle76);
		listCircle.add(Circle77);
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-18 12:04:13.403
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-18 12:04:13.404
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-19 00:47:28.744
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import game.MoveTypeClass.MoveType;
import game.opponent.Engine;
import game.pieces.PieceTypeClass.PieceType;
import game.*;
import javafx.fxml.FXML;
import javafx.scene.Cursor;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.shape.Circle;

public class Controller {
	
	@FXML
	public void opponentPlay(KeyEvent e) {
		KeyCode code = e.getCode();
		  switch(code) {
			case ENTER:
				System.out.println("Engine");
				Engine.playBestMove_alphaBeta(RunningGUI.gameBoard, 4, RunningGUI.gameBoard.colorToPlay);
				this.movePieceFromLastMove();
				
				break;
			case LEFT:
				System.out.println("Left");
				/*
				RunningGUI.gameBoard.unmakeMove();
				RunningGUI.gameBoard.display();
				movePiece(0, 0);
				*/
				break;
			default: break;
		}
	}
	
	@FXML
	private TextField ColorToPlay;
	@FXML
	private TextField Evaluation;
	
	public void setColorToPlay()
	
	@FXML
	private ImageView WRook1;
	private double xwRook1;
	private double ywRook1;
	private int line_WRook1 = 7;
	private int col_WRook1 = 0;
	@FXML
	private ImageView WRook2;
	private double xwRook2;
	private double ywRook2;
	private int line_WRook2 = 7;
	private int col_WRook2 = 7;
	@FXML
	private ImageView BRook1;
	private double xbRook1;
	private double ybRook1;
	private int line_BRook1 = 0;
	private int col_BRook1 = 0;
	@FXML
	private ImageView BRook2;
	private double xbRook2;
	private double ybRook2;
	private int line_BRook2 = 0;
	private int col_BRook2 = 7;
	
	@FXML
	private ImageView WKnight1;
	private double xwKnight1 = 87.5;
	private double ywKnight1 = 612.5;
	private int line_WKnight1 = 7;
	private int col_WKnight1 = 1;
	@FXML
	private ImageView WKnight2;
	private double xwKnight2;
	private double ywKnight2;
	private int line_WKnight2 = 7;
	private int col_WKnight2 = 6;
	@FXML
	private ImageView BKnight1;
	private double xbKnight1;
	private double ybKnight1;
	private int line_BKnight1 = 0;
	private int col_BKnight1 = 1;
	@FXML
	private ImageView BKnight2;
	private double xbKnight2;
	private double ybKnight2;
	private int line_BKnight2 = 0;
	private int col_BKnight2 = 6;
	
	@FXML
	private ImageView WBishop1;
	private double xwBishop1;
	private double ywBishop1;
	private int line_WBishop1 = 7;
	private int col_WBishop1 = 2;
	@FXML
	private ImageView WBishop2;
	private double xwBishop2;
	private double ywBishop2;
	private int line_WBishop2 = 7;
	private int col_WBishop2 = 5;
	@FXML
	private ImageView BBishop1;
	private double xbBishop1;
	private double ybBishop1;
	private int line_BBishop1 = 0;
	private int col_BBishop1 = 2;
	@FXML
	private ImageView BBishop2;
	private double xbBishop2;
	private double ybBishop2;
	private int line_BBishop2 = 0;
	private int col_BBishop2 = 5;
	
	@FXML
	private ImageView WQueen;
	private double xwQueen;
	private double ywQueen;
	private int line_WQueen = 7;
	private int col_WQueen = 3;
	@FXML
	private ImageView BQueen;
	private double xbQueen;
	private double ybQueen;
	private int line_BQueen = 0;
	private int col_BQueen = 3;
	
	@FXML
	private ImageView WKing;
	private double xwKing;
	private double ywKing;
	private int line_WKing = 7;
	private int col_WKing = 4;
	@FXML
	private ImageView BKing;
	private double xbKing;
	private double ybKing;
	private int line_BKing = 0;
	private int col_BKing = 4;
	
	
	@FXML
	private ImageView WPawn1;
	private double xwPawn1;
	private double ywPawn1;
	private int line_WPawn1 = 6;
	private int col_WPawn1 = 0;
	@FXML
	private ImageView WPawn2;
	private double xwPawn2;
	private double ywPawn2;
	private int line_WPawn2 = 6;
	private int col_WPawn2 = 1;
	@FXML
	private ImageView WPawn3;
	private double xwPawn3;
	private double ywPawn3;
	private int line_WPawn3 = 6;
	private int col_WPawn3 = 2;
	@FXML
	private ImageView WPawn4;
	private double xwPawn4;
	private double ywPawn4;
	private int line_WPawn4 = 6;
	private int col_WPawn4 = 3;
	@FXML
	private ImageView WPawn5;
	private double xwPawn5;
	private double ywPawn5;
	private int line_WPawn5 = 6;
	private int col_WPawn5 = 4;
	@FXML
	private ImageView WPawn6;
	private double xwPawn6;
	private double ywPawn6;
	private int line_WPawn6 = 6;
	private int col_WPawn6 = 5;
	@FXML
	private ImageView WPawn7;
	private double xwPawn7;
	private double ywPawn7;
	private int line_WPawn7 = 6;
	private int col_WPawn7 = 6;
	@FXML
	private ImageView WPawn8;
	private double xwPawn8;
	private double ywPawn8;
	private int line_WPawn8 = 6;
	private int col_WPawn8 = 7;
	
	@FXML
	private ImageView BPawn1;
	private double xbPawn1;
	private double ybPawn1;
	private int line_BPawn1 = 1;
	private int col_BPawn1 = 0;
	@FXML
	private ImageView BPawn2;
	private double xbPawn2;
	private double ybPawn2;
	private int line_BPawn2 = 1;
	private int col_BPawn2 = 1;
	@FXML
	private ImageView BPawn3;
	private double xbPawn3;
	private double ybPawn3;
	private int line_BPawn3 = 1;
	private int col_BPawn3 = 2;
	@FXML
	private ImageView BPawn4;
	private double xbPawn4;
	private double ybPawn4;
	private int line_BPawn4 = 1;
	private int col_BPawn4 = 3;
	@FXML
	private ImageView BPawn5;
	private double xbPawn5;
	private double ybPawn5;
	private int line_BPawn5 = 1;
	private int col_BPawn5 = 4;
	@FXML
	private ImageView BPawn6;
	private double xbPawn6;
	private double ybPawn6;
	private int line_BPawn6 = 1;
	private int col_BPawn6 = 5;
	@FXML
	private ImageView BPawn7;
	private double xbPawn7;
	private double ybPawn7;
	private int line_BPawn7 = 1;
	private int col_BPawn7 = 6;
	@FXML
	private ImageView BPawn8;
	private double xbPawn8;
	private double ybPawn8;
	private int line_BPawn8 = 1;
	private int col_BPawn8 = 7;
	
	public void follow_WRook1(MouseEvent e) {
		WRook1.setLayoutX(xwRook1 = e.getSceneX()-(87.5/2));
		WRook1.setLayoutY(ywRook1 = e.getSceneY()-(87.5/2));
		WRook1.toFront();
		WRook1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WRook2(MouseEvent e) {
		WRook2.setLayoutX(xwRook2 = e.getSceneX()-(87.5/2));
		WRook2.setLayoutY(ywRook2 = e.getSceneY()-(87.5/2));
		WRook2.toFront();
		WRook2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BRook1(MouseEvent e) {
		BRook1.setLayoutX(xbRook1 = e.getSceneX()-(87.5/2));
		BRook1.setLayoutY(ybRook1 = e.getSceneY()-(87.5/2));
		BRook1.toFront();
		BRook1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BRook2(MouseEvent e) {
		BRook2.setLayoutX(xbRook2 = e.getSceneX()-(87.5/2));
		BRook2.setLayoutY(ybRook2 = e.getSceneY()-(87.5/2));
		BRook2.toFront();
		BRook2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKnight1(MouseEvent e) {
		WKnight1.setLayoutX(xwKnight1 = e.getSceneX()-(87.5/2));
		WKnight1.setLayoutY(ywKnight1 = e.getSceneY()-(87.5/2));
		WKnight1.toFront();
		WKnight1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKnight2(MouseEvent e) {
		WKnight2.setLayoutX(xwKnight2 = e.getSceneX()-(87.5/2));
		WKnight2.setLayoutY(ywKnight2 = e.getSceneY()-(87.5/2));
		WKnight2.toFront();
		WKnight2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKnight1(MouseEvent e) {
		BKnight1.setLayoutX(xbKnight1 = e.getSceneX()-(87.5/2));
		BKnight1.setLayoutY(ybKnight1 = e.getSceneY()-(87.5/2));
		BKnight1.toFront();
		BKnight1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKnight2(MouseEvent e) {
		BKnight2.setLayoutX(xbKnight2 = e.getSceneX()-(87.5/2));
		BKnight2.setLayoutY(ybKnight2 = e.getSceneY()-(87.5/2));
		BKnight2.toFront();
		BKnight2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WBishop1(MouseEvent e) {
		WBishop1.setLayoutX(xwBishop1 = e.getSceneX()-(87.5/2));
		WBishop1.setLayoutY(ywBishop1 = e.getSceneY()-(87.5/2));
		WBishop1.toFront();
		WBishop1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WBishop2(MouseEvent e) {
		WBishop2.setLayoutX(xwBishop2 = e.getSceneX()-(87.5/2));
		WBishop2.setLayoutY(ywBishop2 = e.getSceneY()-(87.5/2));
		WBishop2.toFront();
		WBishop2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BBishop1(MouseEvent e) {
		BBishop1.setLayoutX(xbBishop1 = e.getSceneX()-(87.5/2));
		BBishop1.setLayoutY(ybBishop1 = e.getSceneY()-(87.5/2));
		BBishop1.toFront();
		BBishop1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BBishop2(MouseEvent e) {
		BBishop2.setLayoutX(xbBishop2 = e.getSceneX()-(87.5/2));
		BBishop2.setLayoutY(ybBishop2 = e.getSceneY()-(87.5/2));
		BBishop2.toFront();
		BBishop2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WQueen(MouseEvent e) {
		WQueen.setLayoutX(xwQueen = e.getSceneX()-(87.5/2));
		WQueen.setLayoutY(ywQueen = e.getSceneY()-(87.5/2));
		WQueen.toFront();
		WQueen.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BQueen(MouseEvent e) {
		BQueen.setLayoutX(xbQueen = e.getSceneX()-(87.5/2));
		BQueen.setLayoutY(ybQueen = e.getSceneY()-(87.5/2));
		BQueen.toFront();
		BQueen.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WKing(MouseEvent e) {
		WKing.setLayoutX(xwKing = e.getSceneX()-(87.5/2));
		WKing.setLayoutY(ywKing = e.getSceneY()-(87.5/2));
		WKing.toFront();
		WKing.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BKing(MouseEvent e) {
		BKing.setLayoutX(xbKing = e.getSceneX()-(87.5/2));
		BKing.setLayoutY(ybKing = e.getSceneY()-(87.5/2));
		BKing.toFront();
		BKing.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn1(MouseEvent e) {
		WPawn1.setLayoutX(xwPawn1 = e.getSceneX()-(87.5/2));
		WPawn1.setLayoutY(ywPawn1 = e.getSceneY()-(87.5/2));
		WPawn1.toFront();
		WPawn1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn2(MouseEvent e) {
		WPawn2.setLayoutX(xwPawn2 = e.getSceneX()-(87.5/2));
		WPawn2.setLayoutY(ywPawn2 = e.getSceneY()-(87.5/2));
		WPawn2.toFront();
		WPawn2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn3(MouseEvent e) {
		WPawn3.setLayoutX(xwPawn3 = e.getSceneX()-(87.5/2));
		WPawn3.setLayoutY(ywPawn3 = e.getSceneY()-(87.5/2));
		WPawn3.toFront();
		WPawn3.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn4(MouseEvent e) {
		WPawn4.setLayoutX(xwPawn4 = e.getSceneX()-(87.5/2));
		WPawn4.setLayoutY(ywPawn4 = e.getSceneY()-(87.5/2));
		WPawn4.toFront();
		WPawn4.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn5(MouseEvent e) {
		WPawn5.setLayoutX(xwPawn5 = e.getSceneX()-(87.5/2));
		WPawn5.setLayoutY(ywPawn5 = e.getSceneY()-(87.5/2));
		WPawn5.toFront();
		WPawn5.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn6(MouseEvent e) {
		WPawn6.setLayoutX(xwPawn6 = e.getSceneX()-(87.5/2));
		WPawn6.setLayoutY(ywPawn6 = e.getSceneY()-(87.5/2));
		WPawn6.toFront();
		WPawn6.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn7(MouseEvent e) {
		WPawn7.setLayoutX(xwPawn7 = e.getSceneX()-(87.5/2));
		WPawn7.setLayoutY(ywPawn7 = e.getSceneY()-(87.5/2));
		WPawn7.toFront();
		WPawn7.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_WPawn8(MouseEvent e) {
		WPawn8.setLayoutX(xwPawn8 = e.getSceneX()-(87.5/2));
		WPawn8.setLayoutY(ywPawn8 = e.getSceneY()-(87.5/2));
		WPawn8.toFront();
		WPawn8.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn1(MouseEvent e) {
		BPawn1.setLayoutX(xbPawn1 = e.getSceneX()-(87.5/2));
		BPawn1.setLayoutY(ybPawn1 = e.getSceneY()-(87.5/2));
		BPawn1.toFront();
		BPawn1.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn2(MouseEvent e) {
		BPawn2.setLayoutX(xbPawn2 = e.getSceneX()-(87.5/2));
		BPawn2.setLayoutY(ybPawn2 = e.getSceneY()-(87.5/2));
		BPawn2.toFront();
		BPawn2.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn3(MouseEvent e) {
		BPawn3.setLayoutX(xbPawn3 = e.getSceneX()-(87.5/2));
		BPawn3.setLayoutY(ybPawn3 = e.getSceneY()-(87.5/2));
		BPawn3.toFront();
		BPawn3.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn4(MouseEvent e) {
		BPawn4.setLayoutX(xbPawn4 = e.getSceneX()-(87.5/2));
		BPawn4.setLayoutY(ybPawn4 = e.getSceneY()-(87.5/2));
		BPawn4.toFront();
		BPawn4.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn5(MouseEvent e) {
		BPawn5.setLayoutX(xbPawn5 = e.getSceneX()-(87.5/2));
		BPawn5.setLayoutY(ybPawn5 = e.getSceneY()-(87.5/2));
		BPawn5.toFront();
		BPawn5.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn6(MouseEvent e) {
		BPawn6.setLayoutX(xbPawn6 = e.getSceneX()-(87.5/2));
		BPawn6.setLayoutY(ybPawn6 = e.getSceneY()-(87.5/2));
		BPawn6.toFront();
		BPawn6.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn7(MouseEvent e) {
		BPawn7.setLayoutX(xbPawn7 = e.getSceneX()-(87.5/2));
		BPawn7.setLayoutY(ybPawn7 = e.getSceneY()-(87.5/2));
		BPawn7.toFront();
		BPawn7.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void follow_BPawn8(MouseEvent e) {
		BPawn8.setLayoutX(xbPawn8 = e.getSceneX()-(87.5/2));
		BPawn8.setLayoutY(ybPawn8 = e.getSceneY()-(87.5/2));
		BPawn8.toFront();
		BPawn8.setCursor(Cursor.CLOSED_HAND);
	}
	
	public void possibleMoves(MouseEvent e) {
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		HashSet<Short> moves = RunningGUI.gameBoard.board[i][j].legalMoves(RunningGUI.gameBoard, i, j);
		if (listCircle.size() == 0) {
			this.setList();
		}
		for (int k=0; k<8; k++) {
			for (int l=0; l<8; l++) {
				if (moves.contains((Object)((short)(10*k+l)))) {
					double opacity = listCircle.get(8*k+l).getOpacity();
					if (opacity == 0) {
						listCircle.get(8*k+l).toFront();
					} else {
						listCircle.get(8*k+l).toBack();
					}
					listCircle.get(8*k+l).setOpacity(0.5-opacity);

				}
			}
		}
	}
	
	public void move_WRook1(MouseEvent e) {
		WRook1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WRook1.toFront();
			RunningGUI.gameBoard.board[line_WRook1][col_WRook1].movePiece(RunningGUI.gameBoard, 
					line_WRook1, col_WRook1, i, j);
			this.reactIfCapture(i, j);
			line_WRook1 = i;
			col_WRook1 = j;
			WRook1.setLayoutX(xwRook1 = col_WRook1*(700/8+0.5));
			WRook1.setLayoutY(ywRook1 = line_WRook1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WRook1.setLayoutX(xwRook1 = col_WRook1*(700/8+0.5));
			WRook1.setLayoutY(ywRook1 = line_WRook1*(700/8+0.5));
		}
	}
	
	public void move_WRook2(MouseEvent e) {
		WRook2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WRook2.toFront();
			RunningGUI.gameBoard.board[line_WRook2][col_WRook2].movePiece(RunningGUI.gameBoard, 
					line_WRook2, col_WRook2, i, j);
			this.reactIfCapture(i, j);
			line_WRook2 = i;
			col_WRook2 = j;
			WRook2.setLayoutX(xwRook2 = col_WRook2*(700/8+0.5));
			WRook2.setLayoutY(ywRook2 = line_WRook2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WRook2.setLayoutX(xwRook2 = col_WRook2*(700/8+0.5));
			WRook2.setLayoutY(ywRook2 = line_WRook2*(700/8+0.5));
		}
	}
	
	public void move_BRook1(MouseEvent e) {
		BRook1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BRook1.toFront();
			RunningGUI.gameBoard.board[line_BRook1][col_BRook1].movePiece(RunningGUI.gameBoard, 
					line_BRook1, col_BRook1, i, j);
			this.reactIfCapture(i, j);
			line_BRook1 = i;
			col_BRook1 = j;
			BRook1.setLayoutX(xbRook1 = col_BRook1*(700/8+0.5));
			BRook1.setLayoutY(ybRook1 = line_BRook1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BRook1.setLayoutX(xbRook1 = col_BRook1*(700/8+0.5));
			BRook1.setLayoutY(ybRook1 = line_BRook1*(700/8+0.5));
		}
	}
	
	public void move_BRook2(MouseEvent e) {
		BRook2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BRook2.toFront();
			RunningGUI.gameBoard.board[line_BRook2][col_BRook2].movePiece(RunningGUI.gameBoard, 
					line_BRook2, col_BRook2, i, j);
			this.reactIfCapture(i, j);
			line_BRook2 = i;
			col_BRook2 = j;
			BRook2.setLayoutX(xbRook2 = col_BRook2*(700/8+0.5));
			BRook2.setLayoutY(ybRook2 = line_BRook2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BRook2.setLayoutX(xbRook2 = col_BRook2*(700/8+0.5));
			BRook2.setLayoutY(ybRook2 = line_BRook2*(700/8+0.5));
		}
	}

	
	public void move_WKnight1(MouseEvent e) {
		WKnight1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKnight1.toFront();
			RunningGUI.gameBoard.board[line_WKnight1][col_WKnight1].movePiece(RunningGUI.gameBoard, 
					line_WKnight1, col_WKnight1, i, j);
			this.reactIfCapture(i, j);
			line_WKnight1 = i;
			col_WKnight1 = j;
			WKnight1.setLayoutX(xwKnight1 = col_WKnight1*(700/8+0.5));
			WKnight1.setLayoutY(ywKnight1 = line_WKnight1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKnight1.setLayoutX(xwKnight1 = col_WKnight1*(700/8+0.5));
			WKnight1.setLayoutY(ywKnight1 = line_WKnight1*(700/8+0.5));
		}
	}
	
	public void move_WKnight2(MouseEvent e) {
		WKnight2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKnight2.toFront();
			RunningGUI.gameBoard.board[line_WKnight2][col_WKnight2].movePiece(RunningGUI.gameBoard, 
					line_WKnight2, col_WKnight2, i, j);
			this.reactIfCapture(i, j);
			line_WKnight2 = i;
			col_WKnight2 = j;
			WKnight2.setLayoutX(xwKnight2 = col_WKnight2*(700/8+0.5));
			WKnight2.setLayoutY(ywKnight2 = line_WKnight2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKnight2.setLayoutX(xwKnight2 = col_WKnight2*(700/8+0.5));
			WKnight2.setLayoutY(ywKnight2 = line_WKnight2*(700/8+0.5));
		}
	}
	
	public void move_BKnight1(MouseEvent e) {
		BKnight1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKnight1.toFront();
			RunningGUI.gameBoard.board[line_BKnight1][col_BKnight1].movePiece(RunningGUI.gameBoard, 
					line_BKnight1, col_BKnight1, i, j);
			this.reactIfCapture(i, j);
			line_BKnight1 = i;
			col_BKnight1 = j;
			BKnight1.setLayoutX(xbKnight1 = col_BKnight1*(700/8+0.5));
			BKnight1.setLayoutY(ybKnight1 = line_BKnight1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKnight1.setLayoutX(xbKnight1 = col_BKnight1*(700/8+0.5));
			BKnight1.setLayoutY(ybKnight1 = line_BKnight1*(700/8+0.5));
		}
	}
	
	public void move_BKnight2(MouseEvent e) {
		BKnight2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKnight2.toFront();
			RunningGUI.gameBoard.board[line_BKnight2][col_BKnight2].movePiece(RunningGUI.gameBoard, 
					line_BKnight2, col_BKnight2, i, j);
			this.reactIfCapture(i, j);
			line_BKnight2 = i;
			col_BKnight2 = j;
			BKnight2.setLayoutX(xbKnight2 = col_BKnight2*(700/8+0.5));
			BKnight2.setLayoutY(ybKnight2 = line_BKnight2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKnight2.setLayoutX(xbKnight2 = col_BKnight2*(700/8+0.5));
			BKnight2.setLayoutY(ybKnight2 = line_BKnight2*(700/8+0.5));
		}
	}
	
	public void move_WBishop1(MouseEvent e) {
		WBishop1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WBishop1.toFront();
			RunningGUI.gameBoard.board[line_WBishop1][col_WBishop1].movePiece(RunningGUI.gameBoard, 
					line_WBishop1, col_WBishop1, i, j);
			this.reactIfCapture(i, j);
			line_WBishop1 = i;
			col_WBishop1 = j;
			WBishop1.setLayoutX(xwBishop1 = col_WBishop1*(700/8+0.5));
			WBishop1.setLayoutY(ywBishop1 = line_WBishop1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WBishop1.setLayoutX(xwBishop1 = col_WBishop1*(700/8+0.5));
			WBishop1.setLayoutY(ywBishop1 = line_WBishop1*(700/8+0.5));
		}
	}
	
	public void move_WBishop2(MouseEvent e) {
		WBishop2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WBishop2.toFront();
			RunningGUI.gameBoard.board[line_WBishop2][col_WBishop2].movePiece(RunningGUI.gameBoard, 
					line_WBishop2, col_WBishop2, i, j);
			this.reactIfCapture(i, j);
			line_WBishop2 = i;
			col_WBishop2 = j;
			WBishop2.setLayoutX(xwBishop2 = col_WBishop2*(700/8+0.5));
			WBishop2.setLayoutY(ywBishop2 = line_WBishop2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WBishop2.setLayoutX(xwBishop2 = col_WBishop2*(700/8+0.5));
			WBishop2.setLayoutY(ywBishop2 = line_WBishop2*(700/8+0.5));
		}
	}
	
	public void move_BBishop1(MouseEvent e) {
		BBishop1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BBishop1.toFront();
			RunningGUI.gameBoard.board[line_BBishop1][col_BBishop1].movePiece(RunningGUI.gameBoard, 
					line_BBishop1, col_BBishop1, i, j);
			this.reactIfCapture(i, j);
			line_BBishop1 = i;
			col_BBishop1 = j;
			BBishop1.setLayoutX(xbBishop1 = col_BBishop1*(700/8+0.5));
			BBishop1.setLayoutY(ybBishop1 = line_BBishop1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BBishop1.setLayoutX(xbBishop1 = col_BBishop1*(700/8+0.5));
			BBishop1.setLayoutY(ybBishop1 = line_BBishop1*(700/8+0.5));
		}
	}
	
	public void move_BBishop2(MouseEvent e) {
		BBishop2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BBishop2.toFront();
			RunningGUI.gameBoard.board[line_BBishop2][col_BBishop2].movePiece(RunningGUI.gameBoard, 
					line_BBishop2, col_BBishop2, i, j);
			this.reactIfCapture(i, j);
			line_BBishop2 = i;
			col_BBishop2 = j;
			BBishop2.setLayoutX(xbBishop2 = col_BBishop2*(700/8+0.5));
			BBishop2.setLayoutY(ybBishop2 = line_BBishop2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BBishop2.setLayoutX(xbBishop2 = col_BBishop2*(700/8+0.5));
			BBishop2.setLayoutY(ybBishop2 = line_BBishop2*(700/8+0.5));
		}
	}
	
	public void move_WQueen(MouseEvent e) {
		WQueen.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WQueen.toFront();
			RunningGUI.gameBoard.board[line_WQueen][col_WQueen].movePiece(RunningGUI.gameBoard, 
					line_WQueen, col_WQueen, i, j);
			this.reactIfCapture(i, j);
			line_WQueen = i;
			col_WQueen = j;
			WQueen.setLayoutX(xwQueen = col_WQueen*(700/8+0.5));
			WQueen.setLayoutY(ywQueen = line_WQueen*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WQueen.setLayoutX(xwQueen = col_WQueen*(700/8+0.5));
			WQueen.setLayoutY(ywQueen = line_WQueen*(700/8+0.5));
		}
	}
	
	public void move_BQueen(MouseEvent e) {
		BQueen.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BQueen.toFront();
			RunningGUI.gameBoard.board[line_BQueen][col_BQueen].movePiece(RunningGUI.gameBoard, 
					line_BQueen, col_BQueen, i, j);
			this.reactIfCapture(i, j);
			line_BQueen = i;
			col_BQueen = j;
			BQueen.setLayoutX(xbQueen = col_BQueen*(700/8+0.5));
			BQueen.setLayoutY(ybQueen = line_BQueen*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BQueen.setLayoutX(xbQueen = col_BQueen*(700/8+0.5));
			BQueen.setLayoutY(ybQueen = line_BQueen*(700/8+0.5));
		}
	}
	
	public void move_WKing(MouseEvent e) {
		WKing.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WKing.toFront();
			RunningGUI.gameBoard.board[line_WKing][col_WKing].movePiece(RunningGUI.gameBoard, 
					line_WKing, col_WKing, i, j);
			this.reactIfCapture(i, j);
			line_WKing = i;
			col_WKing = j;
			WKing.setLayoutX(xwKing = col_WKing*(700/8+0.5));
			WKing.setLayoutY(ywKing = line_WKing*(700/8+0.5));
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.KingSideCastle) {
				WRook2.setLayoutX(xwRook2 = 5*(700/8+0.5));
				WRook2.setLayoutY(ywRook2 = 7*(700/8+0.5));
				line_WRook2 = 7;
				col_WRook2 = 5;
			}
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.QueenSideCastle) {
				WRook1.setLayoutX(xwRook1 = 3*(700/8+0.5));
				WRook1.setLayoutY(ywRook1 = 7*(700/8+0.5));
				line_WRook1 = 7;
				col_WRook1 = 3;
			}
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WKing.setLayoutX(xwKing = col_WKing*(700/8+0.5));
			WKing.setLayoutY(ywKing = line_WKing*(700/8+0.5));
		}
	}
	
	public void move_BKing(MouseEvent e) {
		BKing.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BKing.toFront();
			RunningGUI.gameBoard.board[line_BKing][col_BKing].movePiece(RunningGUI.gameBoard, 
					line_BKing, col_BKing, i, j);
			this.reactIfCapture(i, j);
			line_BKing = i;
			col_BKing = j;
			BKing.setLayoutX(xbKing = col_BKing*(700/8+0.5));
			BKing.setLayoutY(ybKing = line_BKing*(700/8+0.5));
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.KingSideCastle) {
				BRook2.setLayoutX(xbRook2 = 5*(700/8+0.5));
				BRook2.setLayoutY(ybRook2 = 0*(700/8+0.5));
				line_BRook2 = 0;
				col_BRook2 = 5;
			}
			if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.QueenSideCastle) {
				BRook1.setLayoutX(xbRook1 = 3*(700/8+0.5));
				BRook1.setLayoutY(ybRook1 = 0*(700/8+0.5));
				line_BRook1 = 0;
				col_BRook1 = 3;
			}
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BKing.setLayoutX(xbKing = col_BKing*(700/8+0.5));
			BKing.setLayoutY(ybKing = line_BKing*(700/8+0.5));
		}
	}
	
	public void move_WPawn1(MouseEvent e) {
		WPawn1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn1.toFront();
			RunningGUI.gameBoard.board[line_WPawn1][col_WPawn1].movePiece(RunningGUI.gameBoard, 
					line_WPawn1, col_WPawn1, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn1.setImage(White_queen);
			}
			line_WPawn1 = i;
			col_WPawn1 = j;
			WPawn1.setLayoutX(xwPawn1 = col_WPawn1*(700/8+0.5));
			WPawn1.setLayoutY(ywPawn1 = line_WPawn1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn1.setLayoutX(xwPawn1 = col_WPawn1*(700/8+0.5));
			WPawn1.setLayoutY(ywPawn1 = line_WPawn1*(700/8+0.5));
		}
	}
	
	public void move_WPawn2(MouseEvent e) {
		WPawn2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn2.toFront();
			RunningGUI.gameBoard.board[line_WPawn2][col_WPawn2].movePiece(RunningGUI.gameBoard, 
					line_WPawn2, col_WPawn2, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn2.setImage(White_queen);
			}
			line_WPawn2 = i;
			col_WPawn2 = j;
			WPawn2.setLayoutX(xwPawn2 = col_WPawn2*(700/8+0.5));
			WPawn2.setLayoutY(ywPawn2 = line_WPawn2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn2.setLayoutX(xwPawn2 = col_WPawn2*(700/8+0.5));
			WPawn2.setLayoutY(ywPawn2 = line_WPawn2*(700/8+0.5));
		}
	}
	
	public void move_WPawn3(MouseEvent e) {
		WPawn3.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn3.toFront();
			RunningGUI.gameBoard.board[line_WPawn3][col_WPawn3].movePiece(RunningGUI.gameBoard, 
					line_WPawn3, col_WPawn3, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn3.setImage(White_queen);
			}
			line_WPawn3 = i;
			col_WPawn3 = j;
			WPawn3.setLayoutX(xwPawn3 = col_WPawn3*(700/8+0.5));
			WPawn3.setLayoutY(ywPawn3 = line_WPawn3*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn3.setLayoutX(xwPawn3 = col_WPawn3*(700/8+0.5));
			WPawn3.setLayoutY(ywPawn3 = line_WPawn3*(700/8+0.5));
		}
	}
	
	public void move_WPawn4(MouseEvent e) {
		WPawn4.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn4.toFront();
			RunningGUI.gameBoard.board[line_WPawn4][col_WPawn4].movePiece(RunningGUI.gameBoard, 
					line_WPawn4, col_WPawn4, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn4.setImage(White_queen);
			}
			line_WPawn4 = i;
			col_WPawn4 = j;
			WPawn4.setLayoutX(xwPawn4 = col_WPawn4*(700/8+0.5));
			WPawn4.setLayoutY(ywPawn4 = line_WPawn4*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn4.setLayoutX(xwPawn4 = col_WPawn4*(700/8+0.5));
			WPawn4.setLayoutY(ywPawn4 = line_WPawn4*(700/8+0.5));
		}
	}
	
	public void move_WPawn5(MouseEvent e) {
		WPawn5.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn5.toFront();
			RunningGUI.gameBoard.board[line_WPawn5][col_WPawn5].movePiece(RunningGUI.gameBoard, 
					line_WPawn5, col_WPawn5, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn5.setImage(White_queen);
			}
			line_WPawn5 = i;
			col_WPawn5 = j;
			WPawn5.setLayoutX(xwPawn5 = col_WPawn5*(700/8+0.5));
			WPawn5.setLayoutY(ywPawn5 = line_WPawn5*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn5.setLayoutX(xwPawn5 = col_WPawn5*(700/8+0.5));
			WPawn5.setLayoutY(ywPawn5 = line_WPawn5*(700/8+0.5));
		}
	}

	public void move_WPawn6(MouseEvent e) {
		WPawn6.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn6.toFront();
			RunningGUI.gameBoard.board[line_WPawn6][col_WPawn6].movePiece(RunningGUI.gameBoard, 
					line_WPawn6, col_WPawn6, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn6.setImage(White_queen);
			}
			line_WPawn6 = i;
			col_WPawn6 = j;
			WPawn6.setLayoutX(xwPawn6 = col_WPawn6*(700/8+0.5));
			WPawn6.setLayoutY(ywPawn6 = line_WPawn6*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn6.setLayoutX(xwPawn6 = col_WPawn6*(700/8+0.5));
			WPawn6.setLayoutY(ywPawn6 = line_WPawn6*(700/8+0.5));
		}
	}
	
	public void move_WPawn7(MouseEvent e) {
		WPawn7.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn7.toFront();
			RunningGUI.gameBoard.board[line_WPawn7][col_WPawn7].movePiece(RunningGUI.gameBoard, 
					line_WPawn7, col_WPawn7, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn7.setImage(White_queen);
			}
			line_WPawn7 = i;
			col_WPawn7 = j;
			WPawn7.setLayoutX(xwPawn7 = col_WPawn7*(700/8+0.5));
			WPawn7.setLayoutY(ywPawn7 = line_WPawn7*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn7.setLayoutX(xwPawn7 = col_WPawn7*(700/8+0.5));
			WPawn7.setLayoutY(ywPawn7 = line_WPawn7*(700/8+0.5));
		}
	}
	
	public void move_WPawn8(MouseEvent e) {
		WPawn8.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			WPawn8.toFront();
			RunningGUI.gameBoard.board[line_WPawn8][col_WPawn8].movePiece(RunningGUI.gameBoard, 
					line_WPawn8, col_WPawn8, i, j);
			this.reactIfCaptureWPawn(i, j);
			if (i == 0) { //the pawn was promoted
				Image White_queen = new Image("White Queen.png");
				WPawn8.setImage(White_queen);
			}
			line_WPawn8 = i;
			col_WPawn8 = j;
			WPawn8.setLayoutX(xwPawn8 = col_WPawn8*(700/8+0.5));
			WPawn8.setLayoutY(ywPawn8 = line_WPawn8*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			WPawn8.setLayoutX(xwPawn8 = col_WPawn8*(700/8+0.5));
			WPawn8.setLayoutY(ywPawn8 = line_WPawn8*(700/8+0.5));
		}
	}
	
	public void move_BPawn1(MouseEvent e) {
		BPawn1.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn1.toFront();
			RunningGUI.gameBoard.board[line_BPawn1][col_BPawn1].movePiece(RunningGUI.gameBoard, 
					line_BPawn1, col_BPawn1, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn1.setImage(Black_queen);
			}
			line_BPawn1 = i;
			col_BPawn1 = j;
			BPawn1.setLayoutX(xbPawn1 = col_BPawn1*(700/8+0.5));
			BPawn1.setLayoutY(ybPawn1 = line_BPawn1*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn1.setLayoutX(xbPawn1 = col_BPawn1*(700/8+0.5));
			BPawn1.setLayoutY(ybPawn1 = line_BPawn1*(700/8+0.5));
		}
	}
	
	public void move_BPawn2(MouseEvent e) {
		BPawn2.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn2.toFront();
			RunningGUI.gameBoard.board[line_BPawn2][col_BPawn2].movePiece(RunningGUI.gameBoard, 
					line_BPawn2, col_BPawn2, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn2.setImage(Black_queen);
			}
			line_BPawn2 = i;
			col_BPawn2 = j;
			BPawn2.setLayoutX(xbPawn2 = col_BPawn2*(700/8+0.5));
			BPawn2.setLayoutY(ybPawn2 = line_BPawn2*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn2.setLayoutX(xbPawn2 = col_BPawn2*(700/8+0.5));
			BPawn2.setLayoutY(ybPawn2 = line_BPawn2*(700/8+0.5));
		}
	}
	
	public void move_BPawn3(MouseEvent e) {
		BPawn3.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn3.toFront();
			RunningGUI.gameBoard.board[line_BPawn3][col_BPawn3].movePiece(RunningGUI.gameBoard, 
					line_BPawn3, col_BPawn3, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn3.setImage(Black_queen);
			}
			line_BPawn3 = i;
			col_BPawn3 = j;
			BPawn3.setLayoutX(xbPawn3 = col_BPawn3*(700/8+0.5));
			BPawn3.setLayoutY(ybPawn3 = line_BPawn3*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn3.setLayoutX(xbPawn3 = col_BPawn3*(700/8+0.5));
			BPawn3.setLayoutY(ybPawn3 = line_BPawn3*(700/8+0.5));
		}
	}
	
	public void move_BPawn4(MouseEvent e) {
		BPawn4.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn4.toFront();
			RunningGUI.gameBoard.board[line_BPawn4][col_BPawn4].movePiece(RunningGUI.gameBoard, 
					line_BPawn4, col_BPawn4, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn4.setImage(Black_queen);
			}
			line_BPawn4 = i;
			col_BPawn4 = j;
			BPawn4.setLayoutX(xbPawn4 = col_BPawn4*(700/8+0.5));
			BPawn4.setLayoutY(ybPawn4 = line_BPawn4*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn4.setLayoutX(xbPawn4 = col_BPawn4*(700/8+0.5));
			BPawn4.setLayoutY(ybPawn4 = line_BPawn4*(700/8+0.5));
		}
	}
	
	public void move_BPawn5(MouseEvent e) {
		BPawn5.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn5.toFront();
			RunningGUI.gameBoard.board[line_BPawn5][col_BPawn5].movePiece(RunningGUI.gameBoard, 
					line_BPawn5, col_BPawn5, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn5.setImage(Black_queen);
			}
			line_BPawn5 = i;
			col_BPawn5 = j;
			BPawn5.setLayoutX(xbPawn5 = col_BPawn5*(700/8+0.5));
			BPawn5.setLayoutY(ybPawn5 = line_BPawn5*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn5.setLayoutX(xbPawn5 = col_BPawn5*(700/8+0.5));
			BPawn5.setLayoutY(ybPawn5 = line_BPawn5*(700/8+0.5));
		}
	}

	public void move_BPawn6(MouseEvent e) {
		BPawn6.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn6.toFront();
			RunningGUI.gameBoard.board[line_BPawn6][col_BPawn6].movePiece(RunningGUI.gameBoard, 
					line_BPawn6, col_BPawn6, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn6.setImage(Black_queen);
			}
			line_BPawn6 = i;
			col_BPawn6 = j;
			BPawn6.setLayoutX(xbPawn6 = col_BPawn6*(700/8+0.5));
			BPawn6.setLayoutY(ybPawn6 = line_BPawn6*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn6.setLayoutX(xbPawn6 = col_BPawn6*(700/8+0.5));
			BPawn6.setLayoutY(ybPawn6 = line_BPawn6*(700/8+0.5));
		}
	}
	
	public void move_BPawn7(MouseEvent e) {
		BPawn7.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn7.toFront();
			RunningGUI.gameBoard.board[line_BPawn7][col_BPawn7].movePiece(RunningGUI.gameBoard, 
					line_BPawn7, col_BPawn7, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn8.setImage(Black_queen);
			}
			line_BPawn7 = i;
			col_BPawn7 = j;
			BPawn7.setLayoutX(xbPawn7 = col_BPawn7*(700/8+0.5));
			BPawn7.setLayoutY(ybPawn7 = line_BPawn7*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn7.setLayoutX(xbPawn7 = col_BPawn7*(700/8+0.5));
			BPawn7.setLayoutY(ybPawn7 = line_BPawn7*(700/8+0.5));
		}
	}
	
	public void move_BPawn8(MouseEvent e) {
		BPawn8.setCursor(Cursor.OPEN_HAND);
		double x_Mouse = e.getSceneX();
		double y_Mouse = e.getSceneY();
		int j = (int)Math.floor(8*x_Mouse/700);
		int i = (int)Math.floor(8*y_Mouse/700);
		try {
			BPawn8.toFront();
			RunningGUI.gameBoard.board[line_BPawn8][col_BPawn8].movePiece(RunningGUI.gameBoard, 
					line_BPawn8, col_BPawn8, i, j);
			this.reactIfCaptureBPawn(i, j);
			if (i == 7) { //the pawn was promoted
				Image Black_queen = new Image("Black Queen.png");
				BPawn8.setImage(Black_queen);
			}
			line_BPawn8 = i;
			col_BPawn8 = j;
			BPawn8.setLayoutX(xbPawn8 = col_BPawn8*(700/8+0.5));
			BPawn8.setLayoutY(ybPawn8 = line_BPawn8*(700/8+0.5));
			RunningGUI.gameBoard.display();
		} catch (Exception exp) {
			BPawn8.setLayoutX(xbPawn8 = col_BPawn8*(700/8+0.5));
			BPawn8.setLayoutY(ybPawn8 = line_BPawn8*(700/8+0.5));
		}
	}
	
	public void movePieceFromLastMove() {
		Move lastMove = RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1);
		int start_line = lastMove.getStartSquare()/10;
		int start_col = lastMove.getStartSquare() - 10*start_line;
		int landing_line = lastMove.getLandingSquare()/10;
		int landing_col = lastMove.getLandingSquare() - 10*landing_line;
		
		ImageView moving_piece = getPieceOnCoordinate(start_line, start_col);
		
		moving_piece.toFront();
		if (lastMove.getMovedPiece() == PieceType.Pawn) {
			if (lastMove.getColorOfPiece()) {
				this.reactIfCaptureWPawn(landing_line, landing_col);
			} else {
				this.reactIfCaptureBPawn(landing_line, landing_col);
			}
		} else {
			this.reactIfCapture(landing_line, landing_col);
		}
			
		if (lastMove.getMoveType() == MoveType.Promotion) { //the pawn was promoted
			if (lastMove.getColorOfPiece()) {
				Image White_queen = new Image("White Queen.png");
				moving_piece.setImage(White_queen);
			} else {
				Image Black_queen = new Image("Black Queen.png");
				moving_piece.setImage(Black_queen);
			}
		}
			
		if (lastMove.getMoveType() == MoveType.KingSideCastle) {
			if (lastMove.getColorOfPiece()) {
				WRook2.setLayoutX(xwRook2 = 5*(700/8+0.5));
				WRook2.setLayoutY(ywRook2 = 7*(700/8+0.5));
				line_WRook2 = 7;
				col_WRook2 = 5;
			} else {
				BRook2.setLayoutX(xbRook2 = 5*(700/8+0.5));
				BRook2.setLayoutY(ybRook2 = 0*(700/8+0.5));
				line_BRook2 = 0;
				col_BRook2 = 5;
			}
		}
		if (lastMove.getMoveType() == MoveType.QueenSideCastle) {
			if (lastMove.getColorOfPiece()) {
				WRook1.setLayoutX(xwRook1 = 3*(700/8+0.5));
				WRook1.setLayoutY(ywRook1 = 7*(700/8+0.5));
				line_WRook1 = 7;
				col_WRook1 = 3;
			} else {
				BRook1.setLayoutX(xbRook1 = 3*(700/8+0.5));
				BRook1.setLayoutY(ybRook1 = 0*(700/8+0.5));
				line_BRook1 = 0;
				col_BRook1 = 3;
			}
		}
		
		moving_piece.setLayoutX(landing_col*(700/8+0.5));
		moving_piece.setLayoutY(landing_line*(700/8+0.5));
		this.setXSquareOfPiece(landing_col, landing_line, landing_col);
		this.setYSquareOfPiece(landing_col, landing_line, landing_line);
		//RunningGUI.gameBoard.display();
	}
	
	public ImageView getPieceOnCoordinate(double col, double line) {
		double j = col*(700/8+0.5);
		double i = line*(700/8+0.5);
		if (WRook1.getLayoutX() == i && WRook1.getLayoutY() == j) {
			return WRook1;
		}
		if (WRook2.getLayoutX() == i && WRook2.getLayoutY() == j) {
			return WRook2;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (WKnight1.getLayoutX() == i && WKnight1.getLayoutY() == j) {
			return WKnight1;
		}
		if (WKnight2.getLayoutX() == i && WKnight2.getLayoutY() == j) {
			return WKnight2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (WBishop1.getLayoutX() == i && WBishop1.getLayoutY() == j) {
			return WBishop1;
		}
		if (WBishop2.getLayoutX() == i && WBishop2.getLayoutY() == j) {
			return WBishop2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (WQueen.getLayoutX() == i && WQueen.getLayoutY() == j) {
			return WQueen;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (WKing.getLayoutX() == i && WKing.getLayoutY() == j) {
			return WKing;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			return BRook1;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			return BRook2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			return BKnight1;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			return BKnight2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			return BBishop1;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			return BBishop2;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			return BQueen;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			return BKing;
		}
		if (WPawn1.getLayoutX() == i && WPawn1.getLayoutY() == j) {
			return WPawn1;
		}
		if (WPawn2.getLayoutX() == i && WPawn2.getLayoutY() == j) {
			return WPawn2;
		}
		if (WPawn3.getLayoutX() == i && WPawn3.getLayoutY() == j) {
			return WPawn3;
		}
		if (WPawn4.getLayoutX() == i && WPawn4.getLayoutY() == j) {
			return WPawn4;
		}
		if (WPawn5.getLayoutX() == i && WPawn5.getLayoutY() == j) {
			return WPawn5;
		}
		if (WPawn6.getLayoutX() == i && WPawn6.getLayoutY() == j) {
			return WPawn6;
		}
		if (WPawn7.getLayoutX() == i && WPawn7.getLayoutY() == j) {
			return WPawn7;
		}
		if (WPawn8.getLayoutX() == i && WPawn8.getLayoutY() == j) {
			return WPawn8;
		}
		if (BPawn1.getLayoutX() == i && BPawn1.getLayoutY() == j) {
			return BPawn1;
		}
		if (BPawn2.getLayoutX() == i && BPawn2.getLayoutY() == j) {
			return BPawn2;
		}
		if (BPawn3.getLayoutX() == i && BPawn3.getLayoutY() == j) {
			return BPawn3;
		}
		if (BPawn4.getLayoutX() == i && BPawn4.getLayoutY() == j) {
			return BPawn4;
		}
		if (BPawn5.getLayoutX() == i && BPawn5.getLayoutY() == j) {
			return BPawn5;
		}
		if (BPawn6.getLayoutX() == i && BPawn6.getLayoutY() == j) {
			return BPawn6;
		}
		if (BPawn7.getLayoutX() == i && BPawn7.getLayoutY() == j) {
			return BPawn7;
		}
		if (BPawn8.getLayoutX() == i && BPawn8.getLayoutY() == j) {
			return BPawn8;
		}
		return null;
	}
	
	public void setXSquareOfPiece(double col, double line, int x) {
		double j = col*(700/8+0.5);
		double i = line*(700/8+0.5);
		if (WRook1.getLayoutX() == i && WRook1.getLayoutY() == j) {
			xwRook1 = x;
		}
		if (WRook2.getLayoutX() == i && WRook2.getLayoutY() == j) {
			xwRook2 = x;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			xbRook1 = x;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			xbRook2 = x;
		}
		if (WKnight1.getLayoutX() == i && WKnight1.getLayoutY() == j) {
			xwKnight1 = x;
		}
		if (WKnight2.getLayoutX() == i && WKnight2.getLayoutY() == j) {
			xwKnight2 = x;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			xbKnight1 = x;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			xbKnight2 = x;
		}
		if (WBishop1.getLayoutX() == i && WBishop1.getLayoutY() == j) {
			xwBishop1 = x;
		}
		if (WBishop2.getLayoutX() == i && WBishop2.getLayoutY() == j) {
			xwBishop2 = x;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			xbBishop1 = x;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			xbBishop2 = x;
		}
		if (WQueen.getLayoutX() == i && WQueen.getLayoutY() == j) {
			xwQueen = x;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			xbQueen = x;
		}
		if (WKing.getLayoutX() == i && WKing.getLayoutY() == j) {
			xwKing = x;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			xbKing = x;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			xbRook1 = x;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			xbRook2 = x;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			xbRook1 = x;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			xbRook2 = x;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			xbKnight1 = x;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			xbKnight2 = x;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			xbKnight1 = x;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			xbKnight2 = x;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			xbBishop1 = x;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			xbBishop2 = x;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			xbBishop1 = x;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			xbBishop2 = x;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			xbQueen = x;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			xbQueen = x;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			xbKing = x;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			xbKing = x;
		}
		if (WPawn1.getLayoutX() == i && WPawn1.getLayoutY() == j) {
			xwPawn1 = x;
		}
		if (WPawn2.getLayoutX() == i && WPawn2.getLayoutY() == j) {
			xwPawn2 = x;
		}
		if (WPawn3.getLayoutX() == i && WPawn3.getLayoutY() == j) {
			xwPawn3 = x;
		}
		if (WPawn4.getLayoutX() == i && WPawn4.getLayoutY() == j) {
			xwPawn4 = x;
		}
		if (WPawn5.getLayoutX() == i && WPawn5.getLayoutY() == j) {
			xwPawn5 = x;
		}
		if (WPawn6.getLayoutX() == i && WPawn6.getLayoutY() == j) {
			xwPawn6 = x;
		}
		if (WPawn7.getLayoutX() == i && WPawn7.getLayoutY() == j) {
			xwPawn7 = x;
		}
		if (WPawn8.getLayoutX() == i && WPawn8.getLayoutY() == j) {
			xwPawn8 = x;
		}
		if (BPawn1.getLayoutX() == i && BPawn1.getLayoutY() == j) {
			xbPawn1 = x;
		}
		if (BPawn2.getLayoutX() == i && BPawn2.getLayoutY() == j) {
			xbPawn2 = x;
		}
		if (BPawn3.getLayoutX() == i && BPawn3.getLayoutY() == j) {
			xbPawn3 = x;
		}
		if (BPawn4.getLayoutX() == i && BPawn4.getLayoutY() == j) {
			xbPawn4 = x;
		}
		if (BPawn5.getLayoutX() == i && BPawn5.getLayoutY() == j) {
			xbPawn5 = x;
		}
		if (BPawn6.getLayoutX() == i && BPawn6.getLayoutY() == j) {
			xbPawn6 = x;
		}
		if (BPawn7.getLayoutX() == i && BPawn7.getLayoutY() == j) {
			xbPawn7 = x;
		}
		if (BPawn8.getLayoutX() == i && BPawn8.getLayoutY() == j) {
			xbPawn8 = x;
		}
	}
	
	public void setYSquareOfPiece(double col, double line, int y) {
		double j = col*(700/8+0.5);
		double i = line*(700/8+0.5);
		if (WRook1.getLayoutX() == i && WRook1.getLayoutY() == j) {
			ywRook1 = y;
		}
		if (WRook2.getLayoutX() == i && WRook2.getLayoutY() == j) {
			ywRook2 = y;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			ybRook1 = y;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			ybRook2 = y;
		}
		if (WKnight1.getLayoutX() == i && WKnight1.getLayoutY() == j) {
			ywKnight1 = y;
		}
		if (WKnight2.getLayoutX() == i && WKnight2.getLayoutY() == j) {
			ywKnight2 = y;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			ybKnight1 = y;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			ybKnight2 = y;
		}
		if (WBishop1.getLayoutX() == i && WBishop1.getLayoutY() == j) {
			ywBishop1 = y;
		}
		if (WBishop2.getLayoutX() == i && WBishop2.getLayoutY() == j) {
			ywBishop2 = y;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			ybBishop1 = y;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			ybBishop2 = y;
		}
		if (WQueen.getLayoutX() == i && WQueen.getLayoutY() == j) {
			ywQueen = y;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			ybQueen = y;
		}
		if (WKing.getLayoutX() == i && WKing.getLayoutY() == j) {
			ywKing = y;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			ybKing = y;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			ybRook1 = y;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			ybRook2 = y;
		}
		if (BRook1.getLayoutX() == i && BRook1.getLayoutY() == j) {
			ybRook1 = y;
		}
		if (BRook2.getLayoutX() == i && BRook2.getLayoutY() == j) {
			ybRook2 = y;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			ybKnight1 = y;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			ybKnight2 = y;
		}
		if (BKnight1.getLayoutX() == i && BKnight1.getLayoutY() == j) {
			ybKnight1 = y;
		}
		if (BKnight2.getLayoutX() == i && BKnight2.getLayoutY() == j) {
			ybKnight2 = y;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			ybBishop1 = y;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			ybBishop2 = y;
		}
		if (BBishop1.getLayoutX() == i && BBishop1.getLayoutY() == j) {
			ybBishop1 = y;
		}
		if (BBishop2.getLayoutX() == i && BBishop2.getLayoutY() == j) {
			ybBishop2 = y;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			ybQueen = y;
		}
		if (BQueen.getLayoutX() == i && BQueen.getLayoutY() == j) {
			ybQueen = y;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			ybKing = y;
		}
		if (BKing.getLayoutX() == i && BKing.getLayoutY() == j) {
			ybKing = y;
		}
		if (WPawn1.getLayoutX() == i && WPawn1.getLayoutY() == j) {
			ywPawn1 = y;
		}
		if (WPawn2.getLayoutX() == i && WPawn2.getLayoutY() == j) {
			ywPawn2 = y;
		}
		if (WPawn3.getLayoutX() == i && WPawn3.getLayoutY() == j) {
			ywPawn3 = y;
		}
		if (WPawn4.getLayoutX() == i && WPawn4.getLayoutY() == j) {
			ywPawn4 = y;
		}
		if (WPawn5.getLayoutX() == i && WPawn5.getLayoutY() == j) {
			ywPawn5 = y;
		}
		if (WPawn6.getLayoutX() == i && WPawn6.getLayoutY() == j) {
			ywPawn6 = y;
		}
		if (WPawn7.getLayoutX() == i && WPawn7.getLayoutY() == j) {
			ywPawn7 = y;
		}
		if (WPawn8.getLayoutX() == i && WPawn8.getLayoutY() == j) {
			ywPawn8 = y;
		}
		if (BPawn1.getLayoutX() == i && BPawn1.getLayoutY() == j) {
			ybPawn1 = y;
		}
		if (BPawn2.getLayoutX() == i && BPawn2.getLayoutY() == j) {
			ybPawn2 = y;
		}
		if (BPawn3.getLayoutX() == i && BPawn3.getLayoutY() == j) {
			ybPawn3 = y;
		}
		if (BPawn4.getLayoutX() == i && BPawn4.getLayoutY() == j) {
			ybPawn4 = y;
		}
		if (BPawn5.getLayoutX() == i && BPawn5.getLayoutY() == j) {
			ybPawn5 = y;
		}
		if (BPawn6.getLayoutX() == i && BPawn6.getLayoutY() == j) {
			ybPawn6 = y;
		}
		if (BPawn7.getLayoutX() == i && BPawn7.getLayoutY() == j) {
			ybPawn7 = y;
		}
		if (BPawn8.getLayoutX() == i && BPawn8.getLayoutY() == j) {
			ybPawn8 = y;
		}
	}
	
	public void reactIfCapture(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	public void reactIfCaptureWPawn(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.EnPassant) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i+1, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		} else if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	public void reactIfCaptureBPawn(double i, double j) {
		for (Circle circle : listCircle) {
			circle.setOpacity(0);
			circle.toBack();
		}
		if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getMoveType() == MoveType.EnPassant) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i-1, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		} else if (RunningGUI.gameBoard.movesPlayed.get(RunningGUI.gameBoard.movesPlayed.size()-1).getCapturedPiece() != null) {
			ImageView capturedPiece = this.getPieceOnCoordinate(i, j);
			if (capturedPiece != null) {
				capturedPiece.setOpacity(0);
				capturedPiece.setLayoutX(-88);
				capturedPiece.setLayoutY(-88);
			}
		}
	}
	
	
	@FXML
	private Circle Circle00;
	@FXML
	private Circle Circle01;
	@FXML
	private Circle Circle02;
	@FXML
	private Circle Circle03;
	@FXML
	private Circle Circle04;
	@FXML
	private Circle Circle05;
	@FXML
	private Circle Circle06;
	@FXML
	private Circle Circle07;
	@FXML
	private Circle Circle10;
	@FXML
	private Circle Circle11;
	@FXML
	private Circle Circle12;
	@FXML
	private Circle Circle13;
	@FXML
	private Circle Circle14;
	@FXML
	private Circle Circle15;
	@FXML
	private Circle Circle16;
	@FXML
	private Circle Circle17;
	@FXML
	private Circle Circle20;
	@FXML
	private Circle Circle21;
	@FXML
	private Circle Circle22;
	@FXML
	private Circle Circle23;
	@FXML
	private Circle Circle24;
	@FXML
	private Circle Circle25;
	@FXML
	private Circle Circle26;
	@FXML
	private Circle Circle27;
	@FXML
	private Circle Circle30;
	@FXML
	private Circle Circle31;
	@FXML
	private Circle Circle32;
	@FXML
	private Circle Circle33;
	@FXML
	private Circle Circle34;
	@FXML
	private Circle Circle35;
	@FXML
	private Circle Circle36;
	@FXML
	private Circle Circle37;
	@FXML
	private Circle Circle40;
	@FXML
	private Circle Circle41;
	@FXML
	private Circle Circle42;
	@FXML
	private Circle Circle43;
	@FXML
	private Circle Circle44;
	@FXML
	private Circle Circle45;
	@FXML
	private Circle Circle46;
	@FXML
	private Circle Circle47;
	@FXML
	private Circle Circle50;
	@FXML
	private Circle Circle51;
	@FXML
	private Circle Circle52;
	@FXML
	private Circle Circle53;
	@FXML
	private Circle Circle54;
	@FXML
	private Circle Circle55;
	@FXML
	private Circle Circle56;
	@FXML
	private Circle Circle57;
	@FXML
	private Circle Circle60;
	@FXML
	private Circle Circle61;
	@FXML
	private Circle Circle62;
	@FXML
	private Circle Circle63;
	@FXML
	private Circle Circle64;
	@FXML
	private Circle Circle65;
	@FXML
	private Circle Circle66;
	@FXML
	private Circle Circle67;
	@FXML
	private Circle Circle70;
	@FXML
	private Circle Circle71;
	@FXML
	private Circle Circle72;
	@FXML
	private Circle Circle73;
	@FXML
	private Circle Circle74;
	@FXML
	private Circle Circle75;
	@FXML
	private Circle Circle76;
	@FXML
	private Circle Circle77;
	
	private List<Circle> listCircle = new ArrayList<Circle>();
	
	public void setList() {
		listCircle.add(Circle00);
		listCircle.add(Circle01);
		listCircle.add(Circle02);
		listCircle.add(Circle03);
		listCircle.add(Circle04);
		listCircle.add(Circle05);
		listCircle.add(Circle06);
		listCircle.add(Circle07);
		listCircle.add(Circle10);
		listCircle.add(Circle11);
		listCircle.add(Circle12);
		listCircle.add(Circle13);
		listCircle.add(Circle14);
		listCircle.add(Circle15);
		listCircle.add(Circle16);
		listCircle.add(Circle17);
		listCircle.add(Circle20);
		listCircle.add(Circle21);
		listCircle.add(Circle22);
		listCircle.add(Circle23);
		listCircle.add(Circle24);
		listCircle.add(Circle25);
		listCircle.add(Circle26);
		listCircle.add(Circle27);
		listCircle.add(Circle30);
		listCircle.add(Circle31);
		listCircle.add(Circle32);
		listCircle.add(Circle33);
		listCircle.add(Circle34);
		listCircle.add(Circle35);
		listCircle.add(Circle36);
		listCircle.add(Circle37);
		listCircle.add(Circle40);
		listCircle.add(Circle41);
		listCircle.add(Circle42);
		listCircle.add(Circle43);
		listCircle.add(Circle44);
		listCircle.add(Circle45);
		listCircle.add(Circle46);
		listCircle.add(Circle47);
		listCircle.add(Circle50);
		listCircle.add(Circle51);
		listCircle.add(Circle52);
		listCircle.add(Circle53);
		listCircle.add(Circle54);
		listCircle.add(Circle55);
		listCircle.add(Circle56);
		listCircle.add(Circle57);
		listCircle.add(Circle60);
		listCircle.add(Circle61);
		listCircle.add(Circle62);
		listCircle.add(Circle63);
		listCircle.add(Circle64);
		listCircle.add(Circle65);
		listCircle.add(Circle66);
		listCircle.add(Circle67);
		listCircle.add(Circle70);
		listCircle.add(Circle71);
		listCircle.add(Circle72);
		listCircle.add(Circle73);
		listCircle.add(Circle74);
		listCircle.add(Circle75);
		listCircle.add(Circle76);
		listCircle.add(Circle77);
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-19 00:47:28.747
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-19 00:47:28.748
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2022-02-19 12:05:18.643 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-19 12:05:38.743
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 12:05:38.743
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@719bb60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5981f2c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 12:05:38.743
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49639118,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45451333,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-19 12:05:47.080
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\trist'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-02-19 12:06:37.157
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1186)
	at java.base/java.util.Map.of(Map.java:1329)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
